# JAVA基础

### 概述

java优势：最为流行最为广泛；可移植性好、安全可靠、性能较好；开发社区完善，功能丰富。

java应用：桌面应用开发（idea、税务管理软件等）、**企业级应用开发**（微服务、大型互联网应用）、移动应用开发（android、医疗设备）、服务器系统开发（应用后台）、大数据开发（hadoop）、游戏开发等。（行业覆盖率达91%）

java技术体系平台：JAVA SE标准版（核心和基础，用于开发**桌面级应用**，需求量较小）、JAVA EE企业版（多用于**大型网站开发**，是学习的重点）、JAVA ME（用于嵌入式设备技术）、Java Card

java特性：一次编译处处可用，java程序通过javac编译为class文件后，通过各平台的JVM虚拟机均可执行。



下载java后，在bin文件夹中会有两个关键程序：**java为执行工具，javac为编译工具**。

JVM：java虚拟机，是运行java程序的地方。

JDK：java开发工具，包括编译器、虚拟机以及java内置的功能。最常用的版本为JDK8.0，未来会发展JDK11.0作为稳定的平台。【安装JDK时会包含java、javac、jvm和核心类库等java开发运行环境，JDK会关联JRE。】

JRE：java运行环境，JRE可以让计算机系统运行java应用程序；内部包含一个java虚拟机和一些标准的类别函数库。【JRE只包含java、jvm和核心类库等java运行环境。（不含javac）】



**内存图**

java将内存区域划分为：**栈、堆、方法区**、本地方法栈、寄存器

方法区：字节码(class)文件加载时进入的内存、常量池存放位置

栈内存：方法运行时进入的内存（包括变量）、还可以存放基本数据类型的局部变量

堆内存：new的对象在堆内存中开辟空间并产生地址（首先在堆中开辟空间，将产生的地址赋值给栈中的对象，栈保存着该引用对象在堆中的地址）



**注意事项**

* javac编译java源文件(.java)后，会产生字节码文件(.class)；使用java命令执行时，不需要带class

* 使用javap可以将字节码文件**反编码**成一个类[-c 显示汇编代码]

* 旧版本的JDK安装时的PATH需要自己设置，环境变量设置：（文件资源管理器中）此电脑-属性-高级系统设置-高级-环境变量，一般设置两个环境变量：JAVA_HOME：jdk安装位置          Path：JDK的java/javac的安装位置（bin）[%JAVA_HOME%/bin]

* System、String在JDK的Java.lang包下，是默认的包，不需要导入

  

---



# IDEA特性

### **基础**

IDEA规定的**项目结构**：工程(Project)-模块(Module)-包(Package)-类(Class)

IDEA的**源码文件（java文件）**被保存在project的**src**文件夹下。当java文件被运行，会首先被编译为.class文件再运行。**class文件**被存放在project下自动创建的**out**文件夹下。

**package用法**

package的本质是用不同文件夹存放源文件。**具体操作**如下：

源文件**必须**在**最开头**写出自己所在的包：`package packageName;` 

**导入不同包下的类**：`import otherPackage.类名;`，此时可以用`类名`默认的指代该类。（如果不导入外部的类，也可在创建对象时指定（麻烦）：`otherPackage.类名 object = new otherPackage.类名();`）

**命名规则**：只包含数字、字母、下划线和小圆点，不能以数字开头，不能有关键字。一般格式为**小写字母和小圆点：com.公司名.项目名.业务模块名**

**java常用包**：`java.lang.*`（基本包**【系统默认导入】**，包含Integer、String等数据类型类）`java.utils.*`（系统提供的工具包，包含Scanner等）

package的注意事项：（1）同一个package下不允许有两个同名的源文件；（2）即使两个包不同也不可以导入类名相同的类；（3）可以通过`包名`.*`按需导入包下的类，虽然方便但会影响到Java代码的编译速度。不建议；（4）同一个源文件只能有一个类是public的，同一个工程下的其他程序可以调用该类；



**注意事项**

* 使用IDEA自带的导入模块功能，会关联导入原目录的文件，一旦原目录的文件被删除，导入的包也会删除。所以我们建议自己创模块，复制其中的包即可；

* IDEA删除模块时，在菜单中remove只会将模块移除project，而不会删除源文件，要在左上角右键delete；在文件管理器中删除模块不能删干净，要在.idea的modules.xml中进行修改，再重启idea；

  

### 效率

**快捷键**

**ctrl+d 复制当前行**

**ctrl+x 剪切当前行（替换ctrl+y)**

**ctrl+enter 相当于enter后仍定位在原来位置**

**shift+enter 在下一行加行并定位在添加位置**

**ctrl+alt+enter 在前一行加行并定位在添加位置**

ctrl+alt+l	格式化代码

ctrl+i	快速输入重写

alt+insert	生成构造器、扩展、等

**ctrl+/	注释代码**

ctrl+b	定位到方法的定义（ctrl加鼠标左键也行）

ctrl+h	查看层级关系（继承）

tab	自动补全代码也可将类需要的包自动导入



**快捷输入**

**main**	->	public static void main(String[] args) {}

**sout**	->	System.out.println();

**content.sout**	->	System.out.println(content);

**array.fori**	->	for (int i = 0; i < array.length ; i++) {}

**fori**	->	for (int i = 0; i < ; i++) {}

**new Class().var**	-> Class 对象名 = new Class();

**Class.getInstance().var** -> Class 对象名 = Class.getInstance();



### **断点调试 Debug**

断点调试是指在程序中的某一行设置断点，程序运行到该行就会停止。在断点调试过程中，是以对象的**运行类型**来执行的。

**快捷键：**

F7：跳入（跳入到方法内）

alt+shift+F7：强制跳入方法（可以进入到方法更深的位置）

F8：跳过（逐行执行代码）

shift+F8：跳出（跳出当前所在的方法）

F9：resume（执行到下一个断点【我们可以在运行过程中动态添加断点，用于跳过循环等】）



**具体细节：**

* 代码高亮部分为执行当前位置，此时如果该行有方法，可以使用“跳入”进入该方法。

* Console为输出控制台，可以显示代码的输出情况，也可以进行输入操作；Debugger用于追踪代码的运行流程。
* 将光标放在变量上，可以看到最新的数据。





---



# 基础知识

### 数据

**字面量**

字面量包括整型、小数、字符（必须使用单引号，有且只有一个字符）、字符串（必须使用双引号，内容可有可无也可为单字符）、布尔值（true/false)、空值（null)



**变量**

变量在定义是可以没有初始值，但在使用时必须有；变量的有效范围从定义开始到“}”截止，同一范围不能定义两个相同的变量



**数据类型**

数据类型分为引用数据类型和基本数据类型，引用类型的变量存放的是数据在内存中的地址。基本数据类型的变量则存放数据本身，类型包括byte、short、int、long、float、double、char、boolean 8种。
byte(-128~127)，占1个字节；short(-32768~32767)，占2个字节；int，占4个字节；long，占8个字节；
float，占4个字节；double，占8个字节；char，占2个字节；boolean，占1个字节。

**注意：**java中单引号只能用于单个字符，用char修饰；双引号可以用于单个或多个字符时，用String修饰。



**关键字和标志符**

关键字是java内置的一些单词，不能用作类名或变量名；

标志符适用于给类、方法、变量起名的规矩。要求：不能以数字开头、区分大小写、不能是关键字。

命名规范（驼峰模式）：变量首字母小写，类名首字母大写。



**基本数据类**

int/double/long等都是java预定义的数据类型，Boolean、Character、Byte、Short、Integer、Long、Float、Double则是java.lang包（无需import）里定义的类，是Number的子类，包装了基本数据类型，包含多种功能。

* Number的子类作为返回值可以返回null；
* 用值接受子类返回值类型的结果时也要用对应的类来接收；
* `.MAX_VALUE`和`.MIN_VALUE`可以得到相应类型的最大和最小值；
* `.toString()`可以将类型转换为String。





### **类型转换**

* 变量的自动类型转换

 当不同类型的变量赋值给其他类型的变量时会发生自动类型转换，类型范围小的变量可以直接赋值给类型范围大的变量。（byte->short->int->long->float->double 右边可以兼容左边）

* 表达式的自动类型转换

在表达式中，**小范围类型的变量会自动转换成叫大范围的类型再运算**（byte/short/char->int）。表达式的最终结果类型由表达式的最高类型决定。

* 强制类型转换

`数值类型 var1 = (数值类型)var2`

**当类型范围大的数据赋值给类型范围小的变量时**，需要使用强制类型转换，容易造成数据（丢失）溢出。当我们将浮点型强转为整型时，会丢弃小数部分，保留整数部分返回。

```java
double d = 13.4;
long l = (long)d;//double比long的范围更大，大范围的数据可以转换为小范围的数据
int in = 5;
//boolean b = (boolean)in;//报错，int无法转为boolean，如需要转换使用三目运算符
```



### 运算

**运算符**

* 基本运算符

  在java中两个整数相除，得出的是商**向0取整**的值。如果要保留小数，可以在被除数上乘以1.0。
  **+符号在字符串运算时用作连接符；与python不同，java中可以直接将数据与字符串相加，但当遇到数字首先与单个字符相加时，会得到数字与ascii的加和值。**

* 自增自减运算符

  ++/--放在变量前，会先做自增自减，再对变量值进行运算；放在变量后，先计算再对变量自增自减。

  

* 赋值运算符

  扩展赋值运算符：+= -= *= /= %=，其中均隐含了强制类型转换。

  

* 关系运算符

  ==既可以判断基本类型又可以判断引用类型：

  判断基本类型时，判断值是否相等；判断引用类型时，判断地址是否相等（是否是同一个对象）【当遇到向上转型情况时，依旧看其地址是否指向堆中的同一内存】

  

* 逻辑运算符

  & 逻辑与    | 逻辑或    ! 逻辑非    ^ 逻辑异或
  && 短路与：左边为false则右边不执行    || 短路或：左边为true，右边不执行

  

* 三元运算符

  `条件表达式?value1:value2`    条件表达式不需要加括号    



**优先级**

一般而言，单目运算符优先级较高，赋值运算符优先级较低。算术运算符优先级较高，关系和逻辑运算符优先级较低。多数运算符具有左结合性，单目运算符、三目运算符、赋值运算符具有右结合性。

<img src="C:\Users\TRT\AppData\Roaming\Typora\typora-user-images\image-20211203111329317.png" alt="image-20211203111329317" style="zoom:50%;" />





### 常用接口

**键盘录入技术**

API（应用程序编程接口）：Java写好的程序（功能代码）。

```java
Scanner scan = new Scanner(System.in);
String str1 = scan.next();
int num = scan.nextInt();
```



**产生随机数**

```java
Random rand = new Random();
int randomNumber = rand.nextInt(50)+1;//(1-50)	注意，nextInt(bound)方法会产生[0,bound)范围的数字，左闭右开
```



### **程序流程控制**

**for loop语句**

语法格式:	`for(初始化语句;循环判断条件;循环变量迭代){循环操作}`

**for循环细节：**

* 循环判断条件是一个返回boolean的表达式，如果为true则继续执行循环操作，否则退出；
* for循环在初始化后直接进行条件判断，之后每次执行完当前循环是先对循环变量进行迭代之后，然后再判断是否满足判断条件；
* for第三要素，初始化和变量迭代可以省略（写在for前和循环内部），但“;”和判断条件不能省略；
* 循环初始值可以有多条语句，但要求类型一样，中间用逗号隔开；循环变量迭代也一样。

* 知道循环次数用for，知道循环中止情况使用while。`while(true)`和`for(::)`都可完成死循环，一般使用`while(true){}`完成死循环。

**增强for:**

语法：for(element:array){...}

* 对element进行赋值或修改无法真正改变array的值，因为element只有在for循环内有效，修改值需要修改array[i]的值；
* 如果element为一个对象，则要写出他所指向的类名；



**switch case语句**

语法格式：

```java
switch(expression){
    case value :
       //语句
       break; //可选
    case value :
       //语句
       break; //可选
    //你可以有任意数量的case语句
    default : //可选
       //语句
}
```





### 实际练习知识点

### **练习题**

1、数组参与的问题需要考虑代码健壮性：数组长度是否为0（for循环无法使用）、数组是否为null

2、判断String是否相等用String的内部方法`.equals()`。

3、判断语句中`?:`   `&&`   `||`前后的两个条件可以不加括号，因为与 或的优先级很低。

4、获取pi的方法：`Math.PI`



### **小项目**

1、增删改查，被称为crud(create,read,update,delete)

2、带有static的方法称为静态方法，可以直接通过类名调用（不用创建新对象）：`类名.staticMethod();`

3、如果创建的对象只调用一个方法，可以直接用匿名对象调用该方法更简洁：`new 类名().method();`





---



# 数组

数组元素可以是任何类型（只要所有元素具有**相同**的类型）。数组元素可以是**基本数据类型**，数组元素也可以是**类对象**，称这样的数组为对象数组，在这种情况下，数组的每一个元素都是一个对象的引用。

**注意事项**

* 如果访问元素索引大于最大索引，执行会出现**数组索引越界异常**(ArrayIndexOutOfBoundsException) ；
* 如果数组变量中没有存储数组的地址，而是null，在访问数组信息时会出现**空指针异常**(NullPointerException)



### 一维数组

**静态初始化数组**

静态初始化**直接赋值**。

定义方法1：`数值类型[] 数组名 = new 数值类型[]{*elements};`	注意在[]中不用写数组长度，由编译器自动判断；

定义方法2（简化）：`数值类型[] 数组名 = {*elements};`	[]可以写在数组名后；

数组长度：`数组名.length`

数组索引：`数组名[0]`

数组变量名中存储的是数组在内存中的地址，因此数组是**引用类型**。直接打印数组时，输出结果表示数组存放的地址。	e.g.[D@4c873330 	[表示数组，D表示数组为double类型，@表示在..地方，4c873330表示该数组的16位地址。



**动态初始化数组**

动态初始化**先定义后赋值**，定义后数组的类型和长度固定，各元素有一个默认值。	

定义格式：`数值类型[] 数组名 = new 数值类型[arrayLength];`	

默认值：int:0 	float:0.0 	string:null	boolean:false

数组拷贝:

```java
//独立拷贝
int[] arr1 = {10,20,30};//静态初始化
int[] arr2 = new int[arr1.length];//动态初始化
for(int i=0;i<arr1.length;i++){
	arr2[i]=arr1[i];
}
//引用拷贝（互相影响）
int[] arr2=arr1;
```

数组翻转：

```java
// 在原数组翻转
int[] arr = {11,22,33,44,55,66};
for (int i = 0; i < arr.length/2; i++) {//注意java中整数/整数，得到的值为商向0取整的值;因此如果arr.length为奇数，则相当于i<(arr.length-1)/2
    int temp = arr[arr.length-1-i];
    arr[arr.length-1-i] = arr[i];
    arr[i] = temp;
}
//创建新数组逆序赋值
int[] arr2 = new int[arr.length];
for(int i=arr.length-1,j=0)
```



**对象数组**

对象数组的每一个元素都是一个对象的引用；

创建语法：`类名[] 数组名 = new 类名[arrayLength]; `



**内存布局**

数组名表示该数组存放的地址，该地址存放着每一行的地址，每个地址又存放构成各行的元素。



### 二维数组

定义格式：`数值类型[][] 数组名 = {{},{},{}...};`	或	`数值类型[] 数组名[] = {{},{}...};`

动态初始化：`数值类型[][] 数组名 = new 数值类型[arrayLength_y][arrayLength_x];`(定义后二维数组的类型和长度固定，各元素有一个默认值)

遍历二维数组：

```java
for (int i = 0; i < array.length; i++) {
    for (int j = 0; j < array[i].length; j++) System.out.print(array[i][j]+" ");
}
```

二维数组可以只确定行，但每个一维数组均需要重新创建空间：

```java
int[][] array = new int[3][]；
for(int i=0;i<array.length;i++){
	arr[i] = new int[i+1];
	for(int j=0;j<array[i].length;j++){
		arr[i][j] = i+1;
	}
}//array:{{1},{2,2}，{3,3,3}}
```



---



# 方法

方法是一种语法结构，可以把一段代码封装成一个功能，以便重复调用。

**方法的定义和调用**

定义：`访问修饰符 返回值类型 方法名(形参列表){code;	return 返回值;}`

调用：`方法名();`

**注意事项：**

* 方法和方法之间为平级关系，不可嵌套定义，但都是先调用main方法；类则可以，在类内部的类被称为**内部类**；

* 普通方法可以和类名相同，此时它和构造方法唯一的区别就在于有返回类型；

* 同一类的方法直接调用；跨类方法的调用（此时要看方法的访问修饰符），要先创建对象；

* （特殊情况）当成员方法的形参为一个对象时，在方法中将对象置为null，此时不影响实参的对象。因为只改变了额外创建栈空间中的对象的地址，没有修改堆中存放的类本身和主调方法中的对象地址



### 调用

**内存布局**

方法在没有被调用时，在方法区的字节码文件中存放；

方法被调用时，就会在主调方法外开辟一个独立空间（**栈空间**）【所有方法都存放在栈中】；当方法执行完毕或执行到return语句后就会**返回到调用的位置**。



**参数传递**

值传递（形参为基本类型）：在传输实参给方法的形参的时候，并不是传输实参本身，而是传输实参变量中数据值。此时被调用的方法会在栈中新开辟一个空间，形参只在该空间内有效，而不能影响实参本身。

引用传递（形参为引用类型【数组、对象、字符串】）：在传输实参给方法的形参的时候，传递的是引用类型变量在堆中存放的地址，此时不管是发起调用的方法还是被调用的方法都访问堆中的同一个空间。



**递归调用**

递归需要有基线条件，不然会成为死循环

每次递归调用原方法时都会创建一个新的独立空间（栈空间），变量只在栈空间内有效； 



**返回值**

* 返回值类型为void时，可以没有返回值，也可以return关键词单独成行，单独成行可以立即结束当前方法的执行；

* 如果方法要求有返回值类型，则必须与return的值类型一致或兼容（兼容指return后变量的范围小于返回值类型范围）；

* 有返回值的方法调用时可以定义变量接受结果 也可以 单独成行，无返回值方法的调用只能单独成行；

* 一个方法最多只能有一个返回值，但返回值可以是任意类型（基本、引用），因此我们可以通过返回数组返回多个值。



### 重载

重载（overload）是指同一个类中，出 现多个方法名称相同，但**形参列表不同**的**（形参的个数、类型、顺序不同【顺序指形参类型的顺序】）**，这些方法就是重载方法。

优势：可读性好（根据形参实现功能差异化的选择）

注意事项：（1）访问修饰符、返回值不能作为重载的条件；（2）形参名称不同不能构成重载，只是方法的重复调用，会导致报错。  



**可变参数**

java允许同一类中多个同名同功能但参数个数不同的方法，将其封装成一个方法。使用可变参数时，可以当做数组使用。

注意事项：（1）可变参数的实参可以为0个或任意多个。（2）可变参数的实参可以为数组（本质也是）（3）可变参数可以和普通类型的参数一起放在形参列表，但可变参数在最后（4）一个形参列表只能出现一个可变参数

e.g.

```java
public int sum(int... nums){
    int sum = 0;
	for(int i=0;i<nums.length();i++){
        sum += nums[i];
    }
    return sum;
}
```



### 重写

方法重写/覆盖（override），是指**子类**有一个方法和**父类**的名称、返回类型、形参一致。

满足条件：（1）子类方法的**形参列表、方法名称**与父类的完全一样； （2）子类方法的**返回值类型**与父类一样，或是父类返回值类型的子类；（3）子类中重写方法的访问范围应该和父类中一样或更大，不允许子类方法缩小父类的范围

重写override和重载overload要求**方法名**都相同，其**区别**在于：

* 重载发生在本类、重写发生在父类和子类；
* 重载要求**形参列表**的类型、个数和形参属性的顺序至少有一个不同，重写要求**形参列表**完全一样；
* 重载对**返回值类型**无要求，且不能作为重载的条件；重写要求子类重写方法的**返回值类型**和父类中一样或是其子类；
* 重载对**访问修饰符**无要求，且不能作为重载的条件；重写方法要求其子类方法的**访问范围**大于等于父类，即不能缩小父类方法的范围；



---



# 面向对象（基础）

面向对象（Object Oriented）是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用**对象、类、继承、封装、多态**等基本概念来进行程序设计。从现实世界中客观存在的事物（即对象）出发来构造软件系统，并且在系统构造中尽可能运用人类的自然思维方式。

类是共同特征的描述，对象是真实存在的具体实例。

一个类中包括：**成员变量、成员方法、构造器、代码块、内部类**

创建对象格式：`类名 对象名 = new 类名();`	

**new关键字**

使用关键字new来创建一个对象也叫类的**实例化**，使用new创建对象时，会自动调用构造方法初始化对象。

语法：`类名 对象名 = new 类名(); `

new注意事项：（1）`new 类名()`返回一个对象的地址；	(2)new前后两个类名可以不同，此时前一定是后的父类，这被称为多态（向上转型）；

**this关键字**

jvm给每个对象分配this，用于代表**当前对象**，可以用来区分属性和局部变量。

this注意事项：（1）this可以用来访问本类的属性、方法和构造器，不能在类定义的外部使用，只能在类定义的方法中使用；（2）在构造器中访问只能在构造器中访问另一个构造器，此时可以实现构造器的复用：`this(prop1,prop2);`；（3）**this只能放在构造器中的第一句**；

**注意事项**

* 类名首字母需要大写，并满足驼峰模式；
* 一个JAVA文件可以定义多个Class类，**但每个文件中只有一个类是public修饰**，且public修饰的类名必须为文件名；在实际开发中一个文件定义一个class类
* 用new创建但没有用对象接收的对象被称为匿名对象，匿名对象在执行完成后会自动销毁；
* 当令一个对象等于另一个对象，则这两个对象实际上指向的是同一个内存空间；



### **对象内存布局和分配**

1. 创建对象后，会首先在**方法区**加载类的信息；
2. 然后根据类信息在**堆**中分配空间并创建一个对象（每个新对象都会创建一个新的内存空间）；
3. 对象初始化三步骤（1：属性根据类型进行默认初始化；2：根据显式赋值进行初始化；3：检测是否有构造器进行初始化）【如果属性为字符串（引用类型）则属性名指向**方法区的常量池**】
4. 将**堆**中的地址返回给**栈**中的对象引用（在程序中表现为对象名），这个地址会指向该对象（对象中包含对象的属性和方法）。



### 变量

**成员变量（也叫属性、字段）**

属性是类的一个组成部分，一般是基本数据类型,也可以是引用类型。一般无需指定初始化值，变量存在默认值；

定义方法和变量相同：`访问修饰符 数值类型 propertyName;`



**作用域**

变量主要包括局部变量和全局变量。

局部变量：定义在成员方法内部，作用域在定义它的代码块中。必须有初始值。

全局变量（成员变量、属性）：定义在方法外，作用域为整个类体。由于有默认值不一定要赋值。



**注意事项**

* 全局变量和局部变量可以重名，访问时遵循就近原则；

* 在同一个作用域中，两个变量不能重名；

* 局部变量的生命周期短，其随代码块的执行而创建，随代码块的结束而死亡，只存在于一次方法的调用中；全局变量生命周期长，随对象创建而创建，随对象销毁而销毁；

* 全局变量可以加修饰符，局部变量不可以加修饰符；

* 局部变量只能在本类指定方法内使用，全局变量可以被本类和其它类使用。（其它类使用时要创建对象或在形参中传入一个对象）



### **构造器**

构造器又叫构造方法，是类的一种特殊成员方法。主要用于在**创建新对象**时，完成其初始化。构造器**没有返回值和返回类型**，**构造器的方法名和类名需要保持一致**。在对象创建过程中，系统会**自动**调用该类的构造器完成对象的初始化操作。

基本语法：`修饰符 方法名(形参列表){方法体;}`

 e.g. 

```java
//e.g.
public class demo {
    public static void main(String[] args) {
        Person p1 = new Person();
        Person p2 = new Person("tan",12);
        System.out.println(p1.name+' '+p1.age);
        System.out.println(p2.name+' '+p2.age);
    }
}

class Person{
    String name;
    int age;

    Person(){//无参构造器
        age = 10;
    }
    Person(String pName,int pAge){//有参构造器
        name = pName;
        age = pAge;
    }
}
```

**注意事项**

* 一个类可以定义多个不同的构造器（构造器重载）；
* 如果程序中没有定义构造器，则系统会自动为类生成一个默认无参构造器：`类名(){}`；
* 类中一旦自定义了构造器，默认构造器就会被覆盖（此时为了便捷，可以自己定义一个无参构造器用于重载）。



### **访问修饰符**

访问修饰符用于控制**[类、成员变量、成员方法、构造方法]**使用的范围。

**访问修饰符包括public、protected、默认（不写时）、private**，从左到右访问范围逐渐减小；四种访问修饰符的范围如下：
（1）public：公开级别，表示公开访问；
（2）protected：受保护级别,对**子类和同一个包**中的类公开；
（3）不写：默认级别，只对**同一个包**中的类公开；
（4）private：私有级别，只有类本身可以访问，不对外公开。

**访问范围包括：同类、同包、子类、不同包**，从左到右范围逐渐增大；不同访问范围可以允许的权限如下：
（1）**同一个类下**，允许public、protected、默认、private 的变量或方法进行访问；
（2）**同一个包下**，允许public、protected、默认 的变量或方法进行访问；
（3）**子类下**，允许public、protected 的变量或方法进行访问；
（4）**不同包下**，只允许public 的的变量或方法进行访问。

**注意事项**

* 访问级别只适用于类和类的成员，不适用于局部变量；
* 类只能用默认和public进行修饰；
* 虽然低权限的内容只能限定的范围被访问，但可以通过该范围内的方法取得该内容。**（封装）**



### **Object类**

object类是类层次结构的根类，每个类都使用Object作为超类。所有程序都实现这个类的方法。



**equals()方法**

equals()是Object的方法，只能判断引用类型；在Object的多个数据类型的子类中常被重写。

==和equals()的不同点：当对两个对象进行操作时，==比较两个对象的地址是否相等，equals()可以比较两个对象的值是否相等（默认也是比较地址）



**hashCode()方法**

返回该对象的哈希码值。Object类定义的hashCode方法会针对不同的对象返回不同的整数。

作用：

1、主要用于提高具有哈希结构的容器的效率

2、两个引用，如果指向的是同一个对象，则哈希值肯定是一样的；如果指向的是不同对象，则哈希值一般是不一样的。

3、 哈希值主要根据地址计算， 不能完全将哈希值等价于地址。

 

**toString()方法**

返回该对象的字符串表示，默认的toString()方法返回值与**对象引用的值**一致。默认返回：**全类名(包名+类名)+@+哈希值的十六进制**。子类往往重写toString方法，用于返回对象的属性信息。

重写 toString 方法后，打印对象或拼接对象（对象引用）时，都会自动调用该对象的 toString 形式。

获取全类名（在类中） ：`getClass().getName();`

获取对象的hashCode并转成16进制：`Integer.toHexString(hashCode())`



**getClass()方法**

返回对象的运行类型。



**finalize()方法**

当垃圾回收器确定不存在该对象的更多引用时，由对象的垃圾回收器调用此方法。当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以**重写**该方法，完成**资源释放**。

什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用  finalize 方法。垃圾回收机制的调用，由系统来决定(即有自己的GC算法)，也可以通过`System.gc()`主动触发垃圾回收机制。

实际开发中，不会运用finalize方法，理解即可。



---



### 三大特性

### **封装**

封装（**encap**sulation）就是把抽象出的数据（属性）和对数据的操作（方法）封装在一起，数据被保护在内部，程序中的其他部分**只能通过被授权的操作**才能对数据进行操作；

封装的作用：（1）隐藏细节：调用（传入参数）-->方法（连接数据库）；（2）对数据进行验证，保证安全合理

实现步骤：

（1）将属性进行私有化(private)，让外部不能修改属性；

（2）提供一个公共(public)的set方法，用于对属性判断并赋值；也可以通过构造器的方式对属性进行赋值；

（3）提供一个公共的get方法，用于获取属性的值；



### **继承**

继承可以**解决代码复用**，让编程更加接近人类思维，当多个类存在同样的属性和方法时可以从这些类中**抽象**出父类/基类，在父类中定义**相同的属性和方法**。

子类/派生类只需要通过**extends**声明继承父类，此后子类会自动拥有父类定义的属性和方法。子类最多只能继承一个父类（指直接继承），因此java是**单继承机制**。

基本语法：`class subClass extends superClass{}`

设计基本思想：继承必须满足**子类is父类**的逻辑，不能滥用继承。（父类的构造器完成父类属性的初始化，子类的构造器完成子类属性的初始化。）

继承的作用：（1）提高代码的复用性；（2）提高代码的扩展性和可维护性；



**继承本质**

一个子类对象时，会在方法区加载类信息：先由最顶级父类开始依次加载父类的信息，每个阶层的父类的所有属性（无论是否是重复名称的变量，是否private）都会存入到该对象在堆中的空间；

当创建一个子类对象时，会在方法区加载类信息：先由最顶级父类(Object...)开始依次加载父类的信息，每个阶层的父类的所有属性（无论是否是重复名称的变量，是否private）都会存入到该对象在堆中的空间；

当用**子类对象访问属性(prop/this.prop)**时，遵从以下规则：首先看子类自身是否有该属性，如果有并且可以访问则返回子类的这个属性；如果没有该属性，则看父类是否有该属性，如果有则访问且返回，如果没有则依次向上继续该操作；
当用**super方法**在子类访问父类属性或方法时，**从直接父类往上一级**开始寻找。



**super关键字**

super代表父类的引用，用于访问父类的属性、方法、构造器

语法：

* 访问父类的属性（不能访问private属性）：`super.属性名`；
* 访问父类的方法（不能访问private方法）:`super.方法名(参数列表)`; 
* 访问父类的构造器（只能放在**子类构造器**的**第一句**，且**不能**再使用this(参数列表)）：`super(参数列表)；`
  * 在子类构造器中如果不指定或不写父类的构造器则会自动调用无参构造器：`super();`
  * super方法只能放在构造器的第一行（由于this方法也只能放在第一行，所以两个方法不能共存在一个构造器内）；
  * 如果父类**没有实现无参构造器（只有有参）**，子类必须在构造器的第一行指定使用父类的有参构造器；



**注意事项**

* 子类继承父类所有的属性和方法（包括私有），但父类的私有属性或方法不能在子类中直接访问，可以在父类通过公共的方法间接访问；

* 子类创建相关对象（每创一个）时**自动、必须、最先**调用父类的构造器（从最顶级的父类Object开始，逐步往下调用），也可自定义使用指定的父类构造器完成父类的初始化；  
* java的所有类都是Object类的子类，Object是所有类的基类，因此每次调用类的构造器都会先调用Object的构造器； 
* 当子类和父类有**重名**的属性或方法时，必须使用super访问父类的成员，使用this或直接变量名的方式可访问子类的成员；如果没有重名，则直接访问和super/this效果一致。



### 多态

多态（polymorphic)是指方法或对象有多种形态。多态建立在封装和继承之上。主要解决代码中复用性不高的问题，复用性不高导致代码维护困难。

多态的体现：（1）方法的多态：重写和重载；（2）对象的多态：是多态的**核心**，对象多态的前提是两个对象是一对继承关系，具体见下。

对象多态的多种写法：

```java
//(1)向上转型和向下转型
Base a = new Sub();//创建一个父类的对象引用a指向子类对象(向上转型)
Sub a_s = (Sub)a;//将父类的对象引用a强转为子类的对象引用a_s（向下转型）
//((Sub)a).method();//可以调用到子类独有的方法, 常代替上一句（向下转型的简化版）
//(2)形参为父类引用，实参为子类引用时常使用
Sub s = new Sub();//创建一个Sub类型的对象s
Base b = s;//将之前创建的Sub对象的地址赋给b，实际就是将父类引用指向子类对象（向上转型）
//(3)修改对象的运行类型（指向另一个子类）
Base a = new Sub1();//创建一个父类的对象引用a指向子类对象(向上转型)
Sub1.method();//指向Sub1s的method
a = new Sub2();//修改animal的运行类型
Sub2.method();//指向Sub2的method
```





**编译类型和运行类型**

编译类型可以理解为编译器(javac)看到的对象的类型，运行类型可以理解为对象真正执行(java)时的类型。**编译类型在对象定义时=号的左边，运行类型在=号的右边**；

例如`Animal animal = new Dog();`	animal的编译类型时Animal，运行类型是Dog。

判断A的运行类型是否是B或B的子类，返回boolean值：`A instanceof B`



**对象的多态（重要）**

**规则：一个对象的编译类型和运行类型可以不一致；编译类型在定义对象时就已经确定，不可改变，而运行类型可以改变。**

体现：**（1）父类的引用可以指向子类的对象（向上转型）；（2）父类引用可以强制转换为子类引用（向下转型）。**



**向上转型**

向上转型的本质：**父类引用**可以指向**子类对象**。

应用场景：需要用一个方法传入多种子类时，可以使用向上转型。

语法：`父类类型 引用名 = new 子类类型();`

调用规则：

* 实现多态向上转型的对象只能调用父类的所有成员（仍需遵守访问权限），而不能调用子类**特有**（子类有父类无）的成员【若要访问需要向下转型】； 

* 在编译阶段，能调用哪些成员是由**编译类型（父类）**决定的，如果一个方法子类有父类无，用父类引用去访问会报错【该条是上一条的原因】；

* 在执行阶段，程序的最终运行效果是由**运行类型（子类）**决定的，即在出现**重写的方法 被调用**时，按照从子类开始向上查找方法。



**向下转型**

向下转型的本质：将**父类引用**强制转换为**子类引用**。

应用场景：当访问的方法为**子类特有**时，需要将父类引用转换为子类引用再调用。

语法：`子类类型 新子类引用名 = (子类类型)父类引用;`

强转规则：

* 只能强转父类的引用，不能强转父类的对象；
* 强转中要求**父类引用**必须指向的是原有目标类型 （向上转型中的子类）的对象；【如果试图将父类引用转换为其他对象，会报ClassCastException错误】
* 当向下转型后，就可以调用子类类型的所有成员（子类也可向上访问到父类）；

e.g. [exercise demo](F:\MyGit\java\basic-app\src\com\hspedu\polymorphic\exercise)

```java
public class demo {
    public static void main(String[] args) {
        Object obj = "hello";//向上转型：将父类引用(obj)指向子类对象（String的"hello")
        String objStr = (String)obj;//向下转型：将父类引用强制转换为子类引用，父类引用指向的String是当前目标类型
        Object objPri = new Integer(5);//向上转型：将父类引用(Object的obj)指向子类对象（Integer的5)
        //String str = (String)objPri;//报错，因为强转过程中父类引用未指向原有的子类对象(Integer)
        Integer str1 = (Integer)objPri;//向下转型：将父类引用(objPri)强制转换为子类引用(str1),父类引用指向的Integer是原有的目标对象
    }
}
```



**java的动态绑定机制（重要）**

当调用对象**方法**的时候，该方法会和该对象的内存地址/**运行类型**绑定；

当调用对象**属性**的时候， 不会触发动态绑定机制，哪里声明就在哪里使用。

e.g. [DynamicBinding demo](F:\MyGit\java\basic-app\src\com\hspedu\polymorphic\DynamicBinding)

```java
public class DynamicBinding {
    public static void main(String[] args) {
        //a 的编译类型 A, 运行类型 B
        A a = new B();//向上转型
        //由于运行类型B中没有sum()，向上寻找后使用父类的sum()；动态绑定机制使得，sum()中的getI()使用运行类型B中的getI()
        System.out.println(a.sum());
        //由于运行类型B中没有sum1()，向上寻找后使用父类的sum1()；属性没有动态绑定，sum()中的i使用就近类型A中的i（在哪用哪）
        System.out.println(a.sum1());
    }
}

class A {//父类
    public int i = 10;
    //动态绑定机制
    public int sum() {//父类sum()
        return getI() + 10;//20 + 10
    }
    public int sum1() {//父类sum1()
        return i + 10;//10 + 10
    }
    public int getI() {//父类getI  
        return i;
    }
}

class B extends A {//子类
    public int i = 20;
    public int getI() {//子类getI()
        return i;
    }
}
```



**多态的应用**

（1）多态数组：数组的定义类型为父类类型，其中的元素为子类类型

e.g. [Ojbect array demo](F:\MyGit\java\basic-app\src\com\hspedu\polymorphic\array)

```java
public class demo {
    public static void main(String[] args) {
        Person[] persons = new Person[5];//对象数组
        persons[0] = new Person("A", 18);//Person有两个属性：name和age
        persons[1] = new Teacher("B",22,30000);//Teacher继承Person,有特有属性salary
        persons[2] = new Teacher("C",23,20000);
        persons[3] = new Student("D",24,100);//Student继承Person，有特有属性score
        persons[4] = new Student("E",25,97);

        for (int i = 0; i < persons.length; i++) {
            System.out.println(person[i].say()};
    }
}
```

（2）参数多态：通过将子类对象引用作为实参传入形参为父类引用的方法中(父类引用指向子类对象)，实现不同类型对象的传入。

e.g. [Master feed animals demo](F:\MyGit\java\basic-app\src\com\hspedu\polymorphic\basic)

e.g. [Empolyee getAnnual demo](F:\MyGit\java\basic-app\src\com\hspedu\polymorphic\parameter)

```java
//e.g.应用（3）
public class PolyTest {
    public static void main(String[] args) {
//        Animal animal = new Dog();//Animal是编译类型 Dog是运行类型
//        animal.cry();//此时运行Dog的cry():运行时，看animal的运行类型决定该行的执行情况
//        animal = new Cat();//修改了animal的运行类型
//        animal.cry();//此时运行Cat的cry()
        Master master = new Master("Tom");
        Cat c = new Cat("喵喵");//Cat继承Animal
        Dog d = new Dog("大黄");//Dog继承Animal
        Beef f1 = new Beef("五花肉");//Beef继承Food
        Pork f2 = new Pork("牛肚");//Pork继承Food
        master.feed(c,f1);//多态的体现：形参为父类引用，实参为子类引用
        master.feed(d,f2);//同上
    }
}
    }
}
```



---



# 面向对象（高级）

### 静态成员（static关键字）

**静态变量**

**静态变量/静态属性**又称为类变量，由**static**修饰。该变量会被**同一个类的所有对象实例共享**，是该类所有对象共享的变量，任何一个该类的对象访问/修改它时，都是对同一个内存地址存放的变量操作。

**定义**语法：`访问修饰符 static 数值类型 staticVar;`	或	`static 访问修饰符 数值类型 staticVar;`

**访问**类对象的语法：`类名.staticVar`	或	`对象名.staticVar`	(前提是 **满足访问修饰符的访问权限和范围**） 

使用场景：当需要让每个类共享一个变量时，考虑使用类变量。

生命周期：类变量的生命周期由类的加载开始，随类的消亡而销毁；

**类变量注意事项：**

* 类变量是在**类加载**的时候生成和初始化的，即使没有创建对象实例也可以访问；
* 静态变量可以被修改，一旦被修改则所有该类的对象的属性都会被修改；
* 类变量是该类的所有对象共享的，而实例变量（普通属性/非静态变量）是每个对象独享的；
* 非静态变量可以接收静态和非静态变量类型返回值方法，而静态变量只能接收静态变量类型返回值方法；



**静态方法**

类方法就是用static修饰的方法。java中的方法可以分为**静态方法**和**非静态方法**。静态方法和静态数据成员会随着**类加载**而被分配和装载入内存中，非静态成员只有在**类的对象创建时**在对象的内存中才有这个成员的代码段。

定义语法：`访问修饰符 static 数值类型 staticMethod(){}`	或	`static 访问修饰符 数值类型 staticMethod(){}`

访问类方法的语法：`类名.staticMethod()`	或	`对象名.staticMethod()`	(前提是 **满足访问修饰符的访问权限和范围**） 

使用场景：当方法中不涉及任何和对象相关的成员，则可以将方法设计为静态方法，可以不用创建新对象，提高开发效率。



**发生类加载的时刻（☆）：**（1）使用new创建对象实例时；（2）创建子类实例对象时，父类会被加载；（3）**使用类的静态成员时（属性或方法）**



**类方法注意事项:**

* 类方法的**结构信息**和普通方法一样都存放在**方法区**；
* 一般Java中工具类里面的工具方法都用static修饰，作为静态方法；
* 静态方法原则上不允许被重写，因此也不允许被定义为抽象方法； 
* 静态方法中不允许使用this和super等关键字，而非静态方法中隐藏且可以使用这些关键字；
* 构造器属于非静态方法，都可以访问；访问类方法时不会调用构造器，因为没有产生对象；
* **非静态方法既可以**访问静态数据属性/方法**又**可以访问非静态数据属性/方法，而**静态方法只能**访问静态数据属性/方法。



**main方法**

main方法形式：`public static void main(String[] args){}`

解读：（1）main方法由**java虚拟机(jvm)**调用；（2）必须要求**访问权限**为public以供jvm调用；（3）jvm在执行main()方法时不创建新对象，因此是static修饰的**静态方法**。main方法接收String类型的数组参数在args数组中保存执行java命令时传递给所运行类的参数。

args传入的方式：（1）在命令行传入参数`java 类名 param1 param2 param3...`	（2）Idea传入参数Edit Configurations->Program arguments(用空格隔开各个参数)



注意事项：
**在main()方法下**，可以直接调用**main方法所在类**的**静态成员**，但不能访问该类的非静态成员（要通过创建实例对象，通过对象访问非静态成员）



### 代码块

代码化块又称为**初始化块**，属于类中的成员。可以分为**静态代码块**和**普通代码块**，都可以看做**另一种形式的构造器**（对构造器的补充机制），可以做初始化操作；

与方法不同的是，代码块没有方法名，没有返回值，没有参数，只有方法体，而且不用通过对象或类显式调用。其在**加载**类或**创建**类时**隐式调用**。

语法：`[修饰符] {代码};`	修饰符可选(static)，代码最后的;可加可不加。

使用场景：如果多个构造器中有重复的语句，可以抽取到初始化块中，提高代码的重用性；

**静态和普通代码块的区别：**
静态代码块是随着**类的加载**进行的，**只会执行一次**； 
而普通代码块是在**创建一个对象时**执行的，实际先执行的是对象的构造器部分，只是构造器的**最前面**隐含着**super()和普通代码块的调用**，因此每创建一个该类对象就执行一次（与类加载无关，所以只使用静态成员普通代码块不会被调用）

子类构造器的隐藏执行：

```java
public A(){
	//(1)调用super();
	//(2)调用普通代码块和普通属性初始化
	初始化代码...
}
```

**创建对象，在一个类中的调用顺序（☆）**：（1）调用静态代码块和静态属性初始化（两者优先级一致，按定义顺序调用） （2）调用普通代码块和普通属性初始化（两者优先级一致，按定义顺序调用） （3）调用构造方法的显式部分（因为代码块和super()隐藏存在于构造器中，因此是构造器显式部分）

产生继承关系时创建子类对象的调用顺序：
（1）父类静态代码块和静态属性；（两者优先级一致，按定义顺序调用）
（2）子类静态代码块和静态属性；（两者优先级一致，按定义顺序调用）
（3）父类普通代码块和普通属性初始化；（两者优先级一致，按定义顺序调用）
（4）父类构造器；
（5）子类普通代码块和普通属性初始化；（两者优先级一致，按定义顺序调用）
（6）子类构造器；



**基本原则：**

* 静态代码块只能调用静态成员，普通代码块可以调用任意成员；



**注意事项：**

* 调用子类的静态成员时，一定会先加载父类（发生代码块的调用）；
* 代码同时含有静态代码块和普通代码块会一起被调用（无论定义先后，都是静态代码块先被调用）；
* 父类的static方法不可以被子类重写；





### **final关键字**

final可以修饰**类、属性、方法和局部变量**。由final修饰的属性一般称为**常量**。包装类（Integer,Double,String）都是final类。

使用场景：

（1）不希望**类被继承**时，可以用final修饰类；

（2）不希望父类的某个方法被子类**重写或覆盖**(override)时，可以用final关键字修饰；

（3）不希望类的某个**属性的值被修改**，可以用final修饰；

（4）不希望某个**局部变量被修改**，可以用final修饰。



**final变量的初始化**

final修饰的属性必须**在定义时赋予初值**，并且以后**不能修改**； 

final修饰的一般属性的赋值位置可以在**类定义中**、在**构造器中**或在**普通代码块**中（建议在定义时赋值）；如果final修饰的属性是**静态属性**，则初始化的位置只能在**定义中**或**静态代码块**中（不能在构造器，因为静态属性在类加载时就要进行初始化，构造器是在对象创建时调用的）；



**基本原则：**

* final类不能被继承，但可以实例化对象；
* 非final类里如果有final方法，虽然该方法不能被重写，但是可以被继承；
* 如果一个类已经是final类，则没有必要再将方法修饰为final方法；



**注意事项：**

* final不能修饰构造方法；
* final和static往往搭配使用（前后均可），效率更高（底层编译器有相关优化）：当在主方法中调用final修饰的静态变量不会发生类加载。



### 抽象类

当父类的某些方法需要声明，但又不确定如何实现时，可以将其声明为抽象方法，此时该类就是抽象类；所谓抽象方法就是没有实现的方法（没有方法体）。一般来说，抽象类会被继承，由其子类通过重写实现抽象方法。

用abstract关键字修饰该方法则方法称为抽象方法，用abstact修饰类就称为抽象类。

语法：`访问修饰符 abstract 数值类型 方法名(参数列表);`（不能有方法体）	此时类也需要改为：`abstract class 类名{}`


**基本原则：**

* 抽象类**不能被实例化**；

* abstract只能修饰类和方法，不能修饰属性和其它内容；
* 当一个类中存在抽象方法时，必须将该类声明为abtract类；而抽象类不一定要包含abstract方法；
* 抽象方法不能有方法体（大括号）；而如果一个类继承了抽象类，则它必须实现（拥有方法体）抽象类的**所有抽象方法**，除非自身也是抽象类；



**注意事项:**

* 抽象类本质还是类，可以有正常类的相关成员（非抽象方法、构造器、静态方法等）；
* 抽象方法不能使用**private**、**final**和**static**修饰，因为这些关键字都和重写违背。  





### 接口

java中有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。接口可以实现**多重继承**的效果。

接口主要用于给出一些没有实现的方法，将他们封装到一起。当某个类要使用时根据具体情况实现该接口。从本质上讲，接口是一种特殊的**抽象类**，这种抽象类中**只包含常量和方法的定义**，而没有变量和方法的实现。



接口语法：

```java
interface 接口名{
	//属性
	//方法
}
```

实现接口的类语法：

````java
class 类名 implements 接口名{
    //类专有属性
    //类专有方法
    //必须实现的接口中所有抽象方法
}
````

**默认方法**语法（默认方法是一种特殊的方法，主要用于接口中的实现方法）：`访问修饰符 default 数值类型 方法名(){...}`	访问修饰符可以省略，此时默认为public；default也可以放在访问修饰符前。

访问**接口中**的属性（类似于类变量，类的实现可以让类继承接口中的属性）：`接口名.属性名` 或 `实现类名.属性名`或`实现类对象.属性名`



多继承语法：

```java
class 类名 implements 接口1,接口2{
	//类专用属性和方法
    //必须实现的接口1的抽象方法
    //必须实现的接口2的抽象方法
}
```



**基本原则：**

* 接口没有构造方法，因此**不能被实例化**；只能通过**实现(implements)接口的类**进行实例化；
* **普通类**实现接口，必须实现接口中的所有方法；**抽象类**实现接口，可以不实现接口的方法；
* 接口不能继承类，但可以**继承**多个其他接口：`interface A extends B,C{...}`，注意是extends而不是implements；



**注意事项：**

* jdk7前，接口中的所有方法没有方法体，而在jdk8开始接口中可以有**静态方法和默认方法**（默认方法用default修饰）；
* 接口中的**所有成员变量**都默认是由public static final修饰的，可以省略public static、final关键字；接口中的所有方法都默认是由public abstract修饰的，可以省略public和abstract关键字；
* 接口的访问修饰符只能是public或默认，与类的访问修饰符一致；
* 如果父类和其接口有重名的对象，要注意作区分：访问父类用`super.x`，访问接口用`接口名.x`，否则会报错；



**接口和继承的比较**

**解决问题**不同：

继承：当子类继承了父类，就自动拥有了父类的功能；主要价值在于解决代码的复用性和可维护性；

接口：如果子类需要扩展功能，可以通过实现接口的方式扩展。**接口的实现实际是为java单继承机制的补充。**接口的价值在于设计好各种规范，使得可以更好地利用。

**逻辑关系**不同：

逻辑上接口是like a的关系，继承是is a的关系。

**灵活程度**不同：

接口比继承更灵活。接口在一定程度上可以实现代码解耦的功能（接口的规范性+动态绑定）；

**规范和规则**不同：

实现接口的类必须实现接口中所有的方法，而继承中的方法只会出现重写（此时会发生动态绑定）



**接口的多态**

接口引用可以指向实现该接口类的对象（向上转型）；当发生接口的多态时，会执行该接口实现类的方法 （动态绑定）

e.g.

```java
public class ComputerDemo {
    public void work(Usb usb){
        usb.start();
        usb.stop();
    }

    public static void main(String[] args) {
        ComputerDemo c = new ComputerDemo();
        ////这里发生了多态：形参是接口的引用，实参是实现该接口的对象（可以接受手机的对象也可以接受相机的对象）
        //还发生了动态绑定，实参对应对象的运行类型，因此调用的work绑定Camera的work
        c.work(new Camera());
        c.work(new Phone());
    }
}

interface Usb {
    void start();
    void stop();
}

class Camera implements Usb{
    //实现Usb中的抽象方法...
}

class Phone implements Usb{
    //实现Usb中的抽象方法...
}
```

接口多态的传递

e.g.

```java
public class InterfacePolyPass {
    public static void main(String[] args) {
        IG ig = new Teacher();//接口的引用可以指向 实现了该接口类的对象实例
        IH ih = new Teacher();//由于Teacher也实现了IH的接口，因此也可以实现向上转型
    }
}

interface IH{
}

interface IG extends IH{//此时实现IG的类也需要实现IH
}

class Teacher implements IG{
}
```



### 内部类

内部类是指一个类的内部又完整的嵌套了另一个类的结构。被嵌套的类被称为内部类。

内部类的最大特点是：可以**直接访问**外部类的私有属性，可以体现类与类之间的包含关系。

语法：

```java
class Outer{//外部类
	class Inner{//内部类
	//...
    }
}

class Others{//外部其它类
}
```



**内部类的划分**

（1）当内部类定义在外部类局部位置上（比如方法内）：局部内部类（分为有方法名和无方法名，无方法名被称为**匿名内部类**）

（2）当内部类定义在外部类的成员位置上：成员内部类（没有static修饰）、静态内部类（有static修饰）



#### **局部内部类**

局部内部类，是定义在外部类局部位置上，比如方法中（称为方法内部类），并且有类名。

作用域：局部内部类的作用域仅仅在**定义**它的方法或代码块中。



**访问规则：**

* **局部内部类**访问**外部类**的成员：直接访问其全部成员，包括私有成员；

* **外部类**访问**局部内部类**的成员：在定义该内部类的方法或代码块中（作用域）创建内部类的对象，然后再调用方法即可；

* **外部其它类不能**访问**局部内部类**（因为局部内部类属于局部成员，只能在指定的作用域中访问）



**基本原则：**

* 不能给局部内部类添加访问修饰符，但可以用final修饰该类；
* 外部类和局部内部类的成员重名时，默认就近原则；在内部类中访问外部类的成员（如果没有重名可以直接访问）：`外部类名.this.成员`（此处，
  `外部类名.this`本质就是外部类的对象）；



**实践：**

```java
public class demo1 {
    public static void main(String[] args) {
        Outer01 outer01 = new Outer01();
        outer01.m1();
    }
}

class Outer01{
    private int n1 = 100;
    private void n2(){
        System.out.println("outer01 m2()被调用");
    }

    public void m1(){
        final class Inner01{
            public void f1(){
                System.out.println("显示n1="+n1);//可以访问私有成员
                n2();//可以访问私有成员
            }
        }
        Inner01 inner01 = new Inner01();//访问局部内部类的成员（先创建对象，再调用方法）
        inner01.f1();
    }
}
```





#### **匿名内部类（☆）**

匿名内部类定义在外部类的局部位置，通常在方法中，**没有类名**。

匿名内部类在语法上看既有**定义类**的特征，也有**创建对象**的特征。

使用场景：某个内部类只想使用一次，后面不再使用 -> 使用匿名内部类简化开发

作用域和访问规则：同局部内部类。



语法（用对象接收/传入方法）：`接口名/类名 对象 = new 接口名/类名(){...};`(分号不能省)

语法（直接调用）：`new 接口名/类名(){...}.method(参数列表); `	（method在方法体{}中）



**基本原则：**

* 当我们基于**接口名**创建匿名内部类时，编译器底层会自动分配类名：**外部类名$x**，x为匿名内部类的个数（从1开始）；

如果创建了对象，则对象的编译类型为该接口，运行类型为自动分配的类，具体实现为方法体中的内容。显式表达为：

`new 接口名(){...};`	->	`new 外部类名$x implements 接口名{...}`

* 当我们基于**类名**创建匿名内部类时，编译器底层会自动分配类名：**外部类名$x**，x为匿名内部类的个数（从1开始）；

注意该类可以为非抽象类也可以为抽象类，视具体问题而定，如果该类为抽象类则内部类必须实现抽象类的所有方法。

如果创建了对象，则对象的编译类型为该类，运行类型为自动分配的类，具体实现为方法体中的内容。程序会首先运行编译类型的构造器。显式表达为：

`new 类名(参数列表){...};`	->	`new 外部类名$x extends 类名{...}`


**实践：**

匿名内部类可以提高代码的**灵活性**，防止出现硬编码的牵一发而动全身的情况。

e.g.:匿名内部类可以作为实参直接传递(涉及到的知识点：继承、多态、动态绑定、内部类)
```java
public class AnnoymousInnerClassdemo {
    public static void main(String[] args) {
        test(new Test(){//直接将new Test(){}作为实参传给test方法
            @Override
            public void show() {
                System.out.println("显示内容");
            }
        });//匿名内部类，临时创建类有利于代码维护
    }

    public static void test(Test t){
        t.show();
    }
}

interface Test{
    void show();
}
```



#### **非静态成员内部类**

非静态成员内部类定义在外部类的成员位置，没有static修饰。

**作用域：**整个类体

**注意点：**可以为成员内部类添加任意的访问修饰符，因为成员内部类本质上就是一个成员；

**访问规则：**

* **成员内部类**可以直接访问**外部类**的所有成员，包括私有的；

* **外部类**访问**成员内部类**的成员：在外部类中定义一个方法，创建该内部类的对象，再访问；

* **外部其它类**访问**成员内部类**的成员：两种方式

​		[1] `Outer.Inner inner = outer.new Inner();`	用inner对象访问Inner的成员；

​		[2]在外部类中，定义一个方法:`public Inner getInstance(){return new Inner();}`在其他外部类中：`Outer.Inner inner=outer.getInstance();`

* 外部类和内部类的成员重名时，用内部类访问时遵守就近原则优先访问内部的成员。如需要访问外部成员使用：`外部类名.this.成员名`



#### **静态成员内部类**

静态成员内部类定义在外部类的成员位置上，有static修饰。

**作用域：**整个类体 

**注意点：**可以为成员内部类添加任意的访问修饰符，因为成员内部类本质上就是一个成员；

**访问规则：**

* 静态内部类可以直接访问外部类的所有**静态成员**，**不能**访问**非静态成员**；
* 外部类访问静态内部类，需要定义一个方法然后在方法中创建对象，再访问；
* 外部其他类访问匿名内部类成员：[1]`Outer.Inner inner = outer.new Inner();`[2]定义（静态的）返回Inner对象的方法，在外部类`Outer.Inner inner = Outer.getInstance();`（如果为静态方法，可以直接用类名访问）；
* 外部类和内部类的成员重名时，用内部类访问时遵守就近原则优先访问内部的成员。如需要访问外部成员使用：`外部类名.成员名`



---

# 其他操作

### 枚举

枚举（enumeration）写作enum，是一组**常量**的集合。



**自定义类实现枚举**

特点：构造器私有化；本类内部创建一组对象（对外暴露：`public static final`修饰）；提供get方法但不提供set方法。

**使用细节：**

* 不需要提供setXxx方法，因为枚举的对象为可读；

* 对枚举对象/属性使用final+static共同修饰，实现底层优化（在使用枚举对象时不加载类）；

* 枚举对象名通常使用全部大写，这是常量的**命名规范**；

* 枚举对象根据需要，可以有多个属性；



**enum关键字实现枚举类**

特点：用enum代替class；构造器私有化；在枚举类的最前面定义常量对象【对象自动添加public static final修饰】（简便方法）；提供get方法但不提供set方法。

在enum修饰的枚举类中可以用：`常量名(参数列表);	`	代替	`public static final 类名 常量名 = new 类名(参数列表);`

枚举对象的传递：`类名 对象名 = 类名.枚举对象名;`

**使用细节：**

* 使用关键字enum替代class（enum和class、interface的地位相同）；
* 枚举对象必须放在枚举类的行首，且只能有一句（用逗号隔开各个常量对象）；

* 如果有多个常量（对象），使用逗号间隔开：`常量名1(...),常量名2(...),...;`

* 如果使用enum实现枚举，要求将常量对象的定义写在**最前面**，否则报错；
* 如果构造器使用**无参构造器**，则创建常量对象可以省略小括号：`常量名1，常量名2,...;`

**注意事项：**

* 枚举类的构造器（有参/无参）只能是私有的，枚举对象会根据参数列表自动选择使用的构造器；

* 当我们使用enum关键字开发枚举类时，默认会继承Enum类(java.lang.Enum)；

* 如果没有重写toString方法，则enum类会继承Enum类的toString。打印对象时会输出对象名；

* 枚举类默认被final修饰，不能继承任何类，这是因为枚举类隐式继承了Enum，java为单继承；枚举类可以实现接口；

  



**Enum类的内置成员方法**

`枚举对象.name()`	返回枚举对象的名称（不是属性的名称）；

`枚举对象.ordinal()`	返回枚举对象的顺序编号（从0开始）；

`枚举类名[] 数组名 = 枚举类名.values();`	返回定义的**所有**枚举对象（用一个对象数组接收）；

`枚举类名 枚举对象 = 枚举类名.valueOf("字符串");`	将字符串转换成枚举对象，要求字符串必须为已有的常量名（会在枚举类中寻找同名的枚举对象）；

`枚举对象1.compareTo(枚举对象2)`	返回枚举对象是否相等（实际就是用ordinal()方法计算枚举对象的顺序编号之差）；

  

**枚举类实现接口**

枚举类可以实现一个或多个接口。与普通类一样，实现接口的时候需要实现接口中定义的所有方法，若没有完全实现，那这个枚举类就是抽象的，只是不需显式加上abstract修饰，编译器会默认加上。



### **注解**

**介绍：**注解英文名为Annotation，又被称为**元数据**(Metadata)，用于修饰解释 包/类/方法/属性/构造器/局部变量等。和注释一样，注解不影响程序的逻辑，但注解可以被编译和运行，其相当于嵌入到代码中的补充信息。

**使用方法：**使用Annotation时要在其前面加@符号，  并把该Annotation当做一个修饰符使用，用于修饰它支持的程序元素。

**分类：**

（1）`Override`：限定某个方法是重写父类方法，该注解只能用于方法；

（2）`Deprecated`：表示某个程序元素（类、方法）已过时；

（3）`SuppressWarnings`：抑制编译器警告；

**元注解：**用于修饰其他Annotation，包括：（1）Retention（指定注解的作用范围SOURCE CLASS RUNTIME）；（2）Target（指定注解可以在哪些地方使用）；（3）Documented（指定该注解是否会在javadoc中体现）；（4）Inherit（子类会继承父类的注解）





**Override**

@Override表示指定重写父类的方法（从编译层面验证），**只能修饰方法**，不能修饰类、包、属性等。
即使不写该注解依然可以构成重写；但只要写了Override注解，则编译器检查该方法是否为重写方法，如果没有构成重写则会编译错误；



**Deprecated**

@Deprecate用于表示某个程序元素已过时。可以用于修饰方法、类、字段、包、参数等。

被该注解修饰的元素在程序中表示不推荐使用，但是可以使用。用于新旧版本的过渡、兼容使用。

当我们调用Deprecated修饰的元素时，会显示横线。



**SuppressWarnings**

当我们不希望看到警告信息时，可以使用SuppressWarnings注解来抑制警告信息。可以用于修饰具体的语句，方法，类等。

语法：`@SuppressWarnings({"infotype1","infotype2",...})`	不需要分号，注意括号里存放了一个String[]类型的数组。

作用范围：与放置的位置有关

infotype：

| **关键字**               | **用途**                                                     |
| ------------------------ | ------------------------------------------------------------ |
| all                      | to suppress all warnings （抑制所有警告）                    |
| boxing                   | to suppress warnings relative to boxing/unboxing operations （抑制装箱、拆箱操作时候的警告） |
| cast                     | to suppress warnings relative to cast operations （抑制映射相关的警告） |
| dep-ann                  | to suppress warnings relative to deprecated annotation （抑制启用注释的警告） |
| deprecation              | to suppress warnings relative to deprecation （抑制过期方法警告） |
| fallthrough              | to suppress warnings relative to missing breaks in switch statements （抑制确在switch中缺失breaks的警告） |
| finally                  | to suppress warnings relative to finally block that don’t return （抑制finally模块没有返回的警告） |
| hiding                   | to suppress warnings relative to locals that hide variable（抑制相对于隐藏变量的局部变量的警告） |
| incomplete-switch        | to suppress warnings relative to missing entries in a switch statement (enum case)（忽略没有完整的switch语句） |
| nls                      | to suppress warnings relative to non-nls string literals（ 忽略非nls格式的字符） |
| null                     | to suppress warnings relative to null analysis（ 忽略对null的操作） |
| rawtypes                 | to suppress warnings relative to un-specific types when using generics on class params（ 使用generics时忽略没有指定相应的类型） |
| restriction              | to suppress warnings relative to usage of discouraged or forbidden references（ 抑制禁止使用劝阻或禁止引用的警告） |
| serial                   | to suppress warnings relative to missing serialVersionUID field for a serializable class（ 忽略在serializable类中没有声明serialVersionUID变量） |
| static-access            | to suppress warnings relative to incorrect static access（ 抑制不正确的静态访问方式警告） |
| synthetic-access         | to suppress warnings relative to unoptimized access from inner classes（ 抑制子类没有按最优方法访问内部类的警告） |
| unchecked                | to suppress warnings relative to unchecked operations（ 抑制没有进行类型检查操作的警告） |
| unqualified-field-access | to suppress warnings relative to field access unqualified（ 抑制没有权限访问的域的警告） |
| unused                   | to suppress warnings relative to unused code（ 抑制没被使用过的代码的警告） |



