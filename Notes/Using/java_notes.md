### JAVA基础

#### 概述

java优势：最为流行最为广泛；可移植性好、安全可靠、性能较好；开发社区完善，功能丰富。

java应用：桌面应用开发（idea、税务管理软件等）、**企业级应用开发**（微服务、大型互联网应用）、移动应用开发（android、医疗设备）、服务器系统开发（应用后台）、大数据开发（hadoop）、游戏开发等。（行业覆盖率达91%）

java技术体系平台：JAVA SE标准版（核心和基础，用于开发**桌面级应用**，需求量较小）、JAVA EE企业版（多用于**大型网站开发**，是学习的重点）、JAVA ME（用于嵌入式设备技术）、Java Card

java特性：一次编译处处可用，java程序通过javac编译为class文件后，通过各平台的JVM虚拟机均可执行。



下载java后，在bin文件夹中会有两个关键程序：**java为执行工具，javac为编译工具**。

JVM：java虚拟机，是运行java程序的地方。

JDK：java开发工具，包括编译器、虚拟机以及java内置的功能。最常用的版本为JDK8.0，未来会发展JDK11.0作为稳定的平台。【安装JDK时会包含java、javac、jvm和核心类库等java开发运行环境，JDK会关联JRE。】

JRE：java运行环境，JRE可以让计算机系统运行java应用程序；内部包含一个java虚拟机和一些标准的类别函数库。【JRE只包含java、jvm和核心类库等java运行环境。（不含javac）】



**内存图**

java将内存区域划分为：**栈、堆、方法区**、本地方法栈、寄存器

方法区：字节码(class)文件加载时进入的内存、常量池存放位置

栈内存：方法运行时进入的内存（包括变量）、还可以存放基本数据类型的局部变量

堆内存：new的对象在堆内存中开辟空间并产生地址（首先在堆中开辟空间，将产生的地址赋值给栈中的对象，栈保存着该引用对象在堆中的地址）



**注意事项**

* javac编译java源文件(.java)后，会产生字节码文件(.class)；使用java命令执行时，不需要带class

* 使用javap可以将字节码文件反编码成一个类[-c 显示汇编代码]

* 旧版本的JDK安装时的PATH需要自己设置，环境变量设置：（文件资源管理器中）此电脑-属性-高级系统设置-高级-环境变量，一般设置两个环境变量：JAVA_HOME：jdk安装位置          Path：JDK的java/javac的安装位置（bin）[%JAVA_HOME%/bin]

* System、String在JDK的Java.lang包下，是默认的包，不需要导入

  

---



### IDEA特性

#### **基础**

IDEA规定的**项目结构**：工程(Project)-模块(Module)-包(Package)-类(Class)

IDEA的**源码文件（java文件）**被保存在project的**src**文件夹下。当java文件被运行，会首先被编译为.class文件再运行。**class文件**被存放在project下自动创建的**out**文件夹下。

**package用法**

package的本质是用不同文件夹存放源文件。**具体操作**如下：

源文件**必须**在**最开头**写出自己所在的包：`package packageName;` 

**导入不同包下的类**：`import otherPackage.className;`，此时可以用`className`默认的指代该类。（如果不导入外部的类，也可在创建对象时指定（麻烦）：`otherPackage.className object = new otherPackage.className();`）

**命名规则**：只包含数字、字母、下划线和小圆点，不能以数字开头，不能有关键字。一般格式为**小写字母和小圆点：com.公司名.项目名.业务模块名**

**java常用包**：`java.lang.*`（基本包**【系统默认导入】**，包含Integer、String等数据类型类）`java.utils.*`（系统提供的工具包，包含Scanner等）`java.net.*`（用于网络开发）	`java.awt.*`（用于GUI界面开发）

package的注意事项：（1）同一个package下不允许有两个同名的源文件；（2）即使两个包不同也不可以导入类名相同的类；（3）可以通过`packageName.*`按需导入包下的类，虽然方便但会影响到Java代码的编译速度。不建议；（4）同一个源文件只能有一个类是public的，同一个工程下的其他程序可以调用该类；



**注意事项**

* 使用IDEA自带的导入模块功能，会关联导入原目录的文件，一旦原目录的文件被删除，导入的包也会删除。所以我们建议自己创模块，复制其中的包即可；

* IDEA删除模块时，在菜单中remove只会将模块移除project，而不会删除源文件，要在左上角右键delete；在文件管理器中删除模块不能删干净，要在.idea的modules.xml中进行修改，再重启idea；

  

#### 效率

**快捷键**

**ctrl+d 复制当前行**

**ctrl+x 剪切当前行（替换ctrl+y)**

**ctrl+enter 相当于enter后仍定位在原来位置**

**shift+enter 在下一行加行并定位在添加位置**

**ctrl+alt+enter 在前一行加行并定位在添加位置**

ctrl+alt+l	格式化代码

alt+insert	生成构造器、扩展、等

**ctrl+/	注释代码**

ctrl+b	定位到方法的定义（ctrl加鼠标左键也行）

ctrl+h	查看层级关系（继承）

tab	自动补全代码也可将类需要的包自动导入



**快捷输入**

**main**	->	public static void main(String[] args) {}

**sout**	->	System.out.println();

**content.sout**	->	System.out.println(content);

**array.fori**	->	for (int i = 0; i < array.length ; i++) {}

**fori**	->	for (int i = 0; i < ; i++) {}

**new Class().var**	-> Class objectName = new Class();

**Class.getInstance().var** -> Class objectName = Class.getInstance();



#### **断点调试 Debug**

断点调试是指在程序中的某一行设置断点，程序运行到该行就会停止。在断点调试过程中，是以对象的**运行类型**来执行的。

**快捷键：**

F7：跳入（跳入到方法内）

alt+shift+F7：强制跳入方法（可以进入到方法更深的位置）

F8：跳过（逐行执行代码）

shift+F8：跳出（跳出当前所在的方法）

F9：resume（执行到下一个断点【我们可以在运行过程中动态添加断点，用于跳过循环等】）



**具体细节：**

* 代码高亮部分为执行当前位置，此时如果该行有方法，可以使用“跳入”进入该方法。

* Console为输出控制台，可以显示代码的输出情况，也可以进行输入操作；Debugger用于追踪代码的运行流程。
* 将光标放在变量上，可以看到最新的数据。





---



### 基础知识

#### 数据

**字面量**

字面量包括整型、小数、字符（必须使用单引号，有且只有一个字符）、字符串（必须使用双引号，内容可有可无也可为单字符）、布尔值（true/false)、空值（null)



**变量**

变量在定义是可以没有初始值，但在使用时必须有；变量的有效范围从定义开始到“}”截止，同一范围不能定义两个相同的变量



**数据类型**

数据类型分为引用数据类型和基本数据类型，引用类型的变量存放的是数据在内存中的地址。基本数据类型的变量则存放数据本身，类型包括byte、short、int、long、float、double、char、boolean 8种。
byte(-128~127)，占1个字节；short(-32768~32767)，占2个字节；int，占4个字节；long，占8个字节；
float，占4个字节；double，占8个字节；char，占2个字节；boolean，占1个字节。

**注意：**java中单引号只能用于单个字符，用char修饰；双引号可以用于单个或多个字符时，用String修饰。



**关键字和标志符**

关键字是java内置的一些单词，不能用作类名或变量名；

标志符适用于给类、方法、变量起名的规矩。要求：不能以数字开头、区分大小写、不能是关键字。

命名规范（驼峰模式）：变量首字母小写，类名首字母大写。



**基本数据类**

int/double/long等都是java预定义的数据类型，Boolean、Character、Byte、Short、Integer、Long、Float、Double则是java.lang包（无需import）里定义的类，是Number的子类，包装了基本数据类型，包含多种功能。

* Number的子类作为返回值可以返回null；
* 用值接受子类返回值类型的结果时也要用对应的类来接收；
* `.MAX_VALUE`和`.MIN_VALUE`可以得到相应类型的最大和最小值；
* `.toString()`可以将类型转换为String。





#### **类型转换**

* 变量的自动类型转换

 当不同类型的变量赋值给其他类型的变量时会发生自动类型转换，类型范围小的变量可以直接赋值给类型范围大的变量。（byte->short->int->long->float->double 右边可以兼容左边）

* 表达式的自动类型转换

在表达式中，**小范围类型的变量会自动转换成叫大范围的类型再运算**（byte/short/char->int）。表达式的最终结果类型由表达式的最高类型决定。

* 强制类型转换

`type var1 = (type)var2`

**当类型范围大的数据赋值给类型范围小的变量时**，需要使用强制类型转换，容易造成数据（丢失）溢出。当我们将浮点型强转为整型时，会丢弃小数部分，保留整数部分返回。

```java
double d = 13.4;
long l = (long)d;//double比long的范围更大，大范围的数据可以转换为小范围的数据
int in = 5;
//boolean b = (boolean)in;//报错，int无法转为boolean，如需要转换使用三目运算符
```



#### 运算

**运算符**

* 基本运算符

  在java中两个整数相除，得出的是商**向0取整**的值。如果要保留小数，可以在被除数上乘以1.0。
  **+符号在字符串运算时用作连接符；与python不同，java中可以直接将数据与字符串相加，但当遇到数字首先与单个字符相加时，会得到数字与ascii的加和值。**

* 自增自减运算符

  ++/--放在变量前，会先做自增自减，再对变量值进行运算；放在变量后，先计算再对变量自增自减。

  

* 赋值运算符

  扩展赋值运算符：+= -= *= /= %=，其中均隐含了强制类型转换。

  

* 关系运算符

  ==既可以判断基本类型又可以判断引用类型：

  判断基本类型时，判断值是否相等；判断引用类型时，判断地址是否相等（是否是同一个对象）【当遇到向上转型情况时，依旧看其地址是否指向堆中的同一内存】

  

* 逻辑运算符

  & 逻辑与    | 逻辑或    ! 逻辑非    ^ 逻辑异或
  && 短路与：左边为false则右边不执行    || 短路或：左边为true，右边不执行

  

* 三元运算符

  `条件表达式?value1:value2`    条件表达式不需要加括号    



**优先级**

一般而言，单目运算符优先级较高，赋值运算符优先级较低。算术运算符优先级较高，关系和逻辑运算符优先级较低。多数运算符具有左结合性，单目运算符、三目运算符、赋值运算符具有右结合性。

<img src="C:\Users\TRT\AppData\Roaming\Typora\typora-user-images\image-20211203111329317.png" alt="image-20211203111329317" style="zoom:50%;" />





#### 常用接口

**键盘录入技术**

API（应用程序编程接口）：Java写好的程序（功能代码）。

```java
Scanner scan = new Scanner(System.in);
String str1 = scan.next();
int num = scan.nextInt();
```



**产生随机数**

```java
Random rand = new Random();
int randomNumber = rand.nextInt(50)+1;//(1-50)	注意，nextInt(bound)方法会产生[0,bound)范围的数字，左闭右开
```



#### **程序流程控制**

**for loop语句**

语法格式:	`for(初始化语句;循环判断条件;循环变量迭代){循环操作}`

**for循环细节：**

* 循环判断条件是一个返回boolean的表达式，如果为true则继续执行循环操作，否则退出；
* for循环在初始化后直接进行条件判断，之后每次执行完当前循环是先对循环变量进行迭代之后，然后再判断是否满足判断条件；
* for第三要素，初始化和变量迭代可以省略（写在for前和循环内部），但“;”和判断条件不能省略；
* 循环初始值可以有多条语句，但要求类型一样，中间用逗号隔开；循环变量迭代也一样。

* 使用for(element:array){}的写法时，对element进行赋值或修改无法真正改变array的值，因为element只有在for循环内有效，修改值需要修改array[i]的值。
* 知道循环次数用for，知道循环中止情况使用while。`while(true)`和`for(::)`都可完成死循环，一般使用`while(true){}`完成死循环。



**switch case语句**

语法格式：

```java
switch(expression){
    case value :
       //语句
       break; //可选
    case value :
       //语句
       break; //可选
    //你可以有任意数量的case语句
    default : //可选
       //语句
}
```





### 实际练习知识点

#### **练习题**

1、数组参与的问题需要考虑代码健壮性：数组长度是否为0（for循环无法使用）、数组是否为null

2、判断String是否相等用String的内部方法`.equals()`。

3、判断语句中`?:`   `&&`   `||`前后的两个条件可以不加括号，因为与 或的优先级很低。

4、获取pi的方法：`Math.PI`



#### **小项目**

1、增删改查，被称为crud(create,read,update,delete)

2、带有static的方法称为静态方法，可以直接通过类名调用（不用创建新对象）：`className.staticMethod();`

3、如果创建的对象只调用一个方法，可以直接用匿名对象调用该方法更简洁：`new className().method();`





---



### 数组

数组元素可以是任何类型（只要所有元素具有**相同**的类型）。数组元素可以是**基本数据类型**，数组元素也可以是**类对象**，称这样的数组为对象数组，在这种情况下，数组的每一个元素都是一个对象的引用。

**注意事项**

* 如果访问元素索引大于最大索引，执行会出现**数组索引越界异常**(ArrayIndexOutOfBoundsException) ；
* 如果数组变量中没有存储数组的地址，而是null，在访问数组信息时会出现**空指针异常**(NullPointerException)



#### 一维数组

**静态初始化数组**

静态初始化**直接赋值**。

定义方法1：`type[] arrayName = new type[]{*elements};`	注意在[]中不用写数组长度，由编译器自动判断；

定义方法2（简化）：`type[] arrayName = {*elements};`	[]可以写在arrayName后；

数组长度：`arrayName.length`

数组索引：`arrayName[0]`

数组变量名中存储的是数组在内存中的地址，因此数组是**引用类型**。直接打印数组时，输出结果表示数组存放的地址。	e.g.[D@4c873330 	[表示数组，D表示数组为double类型，@表示在..地方，4c873330表示该数组的16位地址。



**动态初始化数组**

动态初始化**先定义后赋值**，定义后数组的类型和长度固定，各元素有一个默认值。	

定义格式：`type[] arrayName = new type[arrayLength];`	

默认值：int:0 	float:0.0 	string:null	boolean:false

数组拷贝:

```java
//独立拷贝
int[] arr1 = {10,20,30};//静态初始化
int[] arr2 = new int[arr1.length];//动态初始化
for(int i=0;i<arr1.length;i++){
	arr2[i]=arr1[i];
}
//引用拷贝（互相影响）
int[] arr2=arr1;
```

数组翻转：

```java
// 在原数组翻转
int[] arr = {11,22,33,44,55,66};
for (int i = 0; i < arr.length/2; i++) {//注意java中整数/整数，得到的值为商向0取整的值;因此如果arr.length为奇数，则相当于i<(arr.length-1)/2
    int temp = arr[arr.length-1-i];
    arr[arr.length-1-i] = arr[i];
    arr[i] = temp;
}
//创建新数组逆序赋值
int[] arr2 = new int[arr.length];
for(int i=arr.length-1,j=0)
```



**对象数组**

对象数组的每一个元素都是一个对象的引用；

创建语法：`className[] arrayname = new className[arrayLength]; `



**内存布局**

数组名表示该数组存放的地址，该地址存放着每一行的地址，每个地址又存放构成各行的元素。



#### 二维数组

定义格式：`type[][] arrayName = {{},{},{}...};`	或	`type[] arrayName[] = {{},{}...};`

动态初始化：`type[][] arrayName = new type[arrayLength_y][arrayLength_x];`(定义后二维数组的类型和长度固定，各元素有一个默认值)

遍历二维数组：

```java
for (int i = 0; i < array.length; i++) {
    for (int j = 0; j < array[i].length; j++) System.out.print(array[i][j]+" ");
}
```

二维数组可以只确定行，但每个一维数组均需要重新创建空间：

```java
int[][] array = new int[3][]；
for(int i=0;i<array.length;i++){
	arr[i] = new int[i+1];
	for(int j=0;j<array[i].length;j++){
		arr[i][j] = i+1;
	}
}//array:{{1},{2,2}，{3,3,3}}
```



---



### 方法

方法是一种语法结构，可以把一段代码封装成一个功能，以便重复调用。

**方法的定义和调用**

定义：`访问修饰符 返回值类型 方法名(形参列表){code;	return 返回值;}`

调用：`方法名();`

**注意事项：**

* 方法和方法之间为平级关系，不可嵌套定义，但都是先调用main方法；类则可以，在类内部的类被称为内部类；

* 普通方法可以和类名相同，此时它和构造方法唯一的区别就在于有返回类型；

* 同一类的方法直接调用；跨类方法的调用（此时要看方法的访问修饰符），要先创建对象；

* （特殊情况）当成员方法的形参为一个对象时，在方法中将对象置为null，此时不影响实参的对象。因为只改变了额外创建栈空间中的对象的地址，没有修改堆中存放的类本身和主调方法中的对象地址



#### 调用

**内存布局**

方法在没有被调用时，在方法区的字节码文件中存放；

方法被调用时，就会在主调方法外开辟一个独立空间（**栈空间**）【所有方法都存放在栈中】；当方法执行完毕或执行到return语句后就会**返回到调用的位置**。



**参数传递**

值传递（形参为基本类型）：在传输实参给方法的形参的时候，并不是传输实参本身，而是传输实参变量中数据值。此时被调用的方法会在栈中新开辟一个空间，形参只在该空间内有效，而不能影响实参本身。

引用传递（形参为引用类型【数组、对象、字符串】）：在传输实参给方法的形参的时候，传递的是引用类型变量在堆中存放的地址，此时不管是发起调用的方法还是被调用的方法都访问堆中的同一个空间。



**递归调用**

递归需要有基线条件，不然会成为死循环

每次递归调用原方法时都会创建一个新的独立空间（栈空间），变量只在栈空间内有效； 



**返回值**

* 返回值类型为void时，可以没有返回值，也可以return关键词单独成行，单独成行可以立即结束当前方法的执行；

* 如果方法要求有返回值类型，则必须与return的值类型一致或兼容（兼容指return后变量的范围小于返回值类型范围）；

* 有返回值的方法调用时可以定义变量接受结果 也可以 单独成行，无返回值方法的调用只能单独成行；

* 一个方法最多只能有一个返回值，但返回值可以是任意类型（基本、引用），因此我们可以通过返回数组返回多个值。



#### 重载

重载（overload）是指同一个类中，出 现多个方法名称相同，但**形参列表不同**的**（形参的个数、类型、顺序不同【顺序指形参类型的顺序】）**，这些方法就是重载方法。

优势：可读性好（根据形参实现功能差异化的选择）

注意事项：（1）访问修饰符、返回值不能作为重载的条件；（2）形参名称不同不能构成重载，只是方法的重复调用，会导致报错。  



**可变参数**

java允许同一类中多个同名同功能但参数个数不同的方法，将其封装成一个方法。使用可变参数时，可以当做数组使用。

注意事项：（1）可变参数的实参可以为0个或任意多个。（2）可变参数的实参可以为数组（本质也是）（3）可变参数可以和普通类型的参数一起放在形参列表，但可变参数在最后（4）一个形参列表只能出现一个可变参数

e.g.

```java
public int sum(int... nums){
    int sum = 0;
	for(int i=0;i<nums.length();i++){
        sum += nums[i];
    }
    return sum;
}
```



#### 重写

方法重写/覆盖（override），是指**子类**有一个方法和**父类**的名称、返回类型、形参一致。

满足条件：（1）子类方法的**形参列表、方法名称**与父类的完全一样； （2）子类方法的**返回值类型**与父类一样，或是父类返回值类型的子类；（3）子类中重写方法的访问范围应该和父类中一样或更大，不允许子类方法缩小父类的范围

重写override和重载overload要求**方法名**都相同，其**区别**在于：

* 重载发生在本类、重写发生在父类和子类；
* 重载要求**形参列表**的类型、个数和形参属性的顺序至少有一个不同，重写要求**形参列表**完全一样；
* 重载对**返回值类型**无要求，且不能作为重载的条件；重写要求子类重写方法的**返回值类型**和父类中一样或是其子类；
* 重载对**访问修饰符**无要求，且不能作为重载的条件；子类方法要求其重写方法的**访问范围**大于等于父类，即不能缩小父类方法的范围；



---



### 面向对象（基础）

面向对象（Object Oriented）是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用**对象、类、继承、封装、多态**等基本概念来进行程序设计。从现实世界中客观存在的事物（即对象）出发来构造软件系统，并且在系统构造中尽可能运用人类的自然思维方式。

类是共同特征的描述，对象是真实存在的具体实例。

一个类中包括：**成员变量、成员方法、构造器、代码块、内部类**

创建对象格式：`className objectName = new className();`	



#### 基础

##### **对象内存布局和分配**

1. 创建对象后，会首先在**方法区**加载类的信息；
2. 然后根据类信息在**堆**中分配空间并创建一个对象（每个新对象都会创建一个新的内存空间）；
3. 对象初始化三步骤（1：属性根据类型进行默认初始化；2：根据显式赋值进行初始化；3：检测是否有构造器进行初始化）【如果属性为字符串（引用类型）则属性名指向**方法区的常量池**】
4. 将**堆**中的地址返回给**栈**中的对象引用（在程序中表现为对象名），这个地址会指向该对象（对象中包含对象的属性和方法）。



##### **new关键字**

使用关键字new来创建一个对象也叫类的**实例化**，使用new创建对象时，会自动调用构造方法初始化对象。

语法：`className objectName = new className(); `

new注意事项：（1）`new className()`返回一个对象的地址；	(2)new前后两个className可以不同，此时前一定是后的父类，这被称为多态（向上转型）；



##### **this关键字**

jvm给每个对象分配this，用于代表**当前对象**，可以用来区分属性和局部变量。

this注意事项：（1）this可以用来访问本类的属性、方法和构造器，不能在类定义的外部使用，只能在类定义的方法中使用；（2）在构造器中访问只能在构造器中访问另一个构造器，此时可以实现构造器的复用：`this(prop1,prop2);`；（3）**this只能放在构造器中的第一句**；



**注意事项**

* 类名首字母需要大写，并满足驼峰模式；
* 一个JAVA文件可以定义多个Class类，**但只有一个类是public修饰**，且public修饰的类名必须为文件名；在实际开发中一个文件定义一个class类
* 用new创建但没有用对象接收的对象被称为匿名对象，匿名对象在执行完成后会自动销毁；
* 当令一个对象等于另一个对象，则这两个对象实际上指向的是同一个内存空间



#### 变量

**成员变量（也叫属性、字段）**

属性是类的一个组成部分，一般是基本数据类型,也可以是引用类型。一般无需指定初始化值，变量存在默认值；

定义方法和变量相同：`访问修饰符 type propertyName;`



**作用域**

变量主要包括局部变量和全局变量。

局部变量：定义在成员方法内部，作用域在定义它的代码块中。必须有初始值。

全局变量（成员变量、属性）：定义在方法外，作用域为整个类体。由于有默认值不一定要赋值。



**注意事项**

* 全局变量和局部变量可以重名，访问时遵循就近原则；

* 在同一个作用域中，两个变量不能重名；

* 局部变量的生命周期短，其随代码块的执行而创建，随代码块的结束而死亡，只存在于一次方法的调用中；全局变量生命周期长，随对象创建而创建，随对象销毁而销毁；

* 全局变量可以加修饰符，局部变量不可以加修饰符；

* 局部变量只能在本类指定方法内使用，全局变量可以被本类和其它类使用。（其它类使用时要创建对象或在形参中传入一个对象）



#### **构造器**

构造器又叫构造方法，是类的一种特殊成员方法。主要用于在**创建新对象**时，完成其初始化。构造器**没有返回值和返回类型**，**构造器的方法名和类名需要保持一致**。在对象创建过程中，系统会**自动**调用该类的构造器完成对象的初始化操作。

基本语法：`修饰符 方法名(形参列表){方法体;}`

 e.g. 

```java
//e.g.
public class demo {
    public static void main(String[] args) {
        Person p1 = new Person();
        Person p2 = new Person("tan",12);
        System.out.println(p1.name+' '+p1.age);
        System.out.println(p2.name+' '+p2.age);
    }
}

class Person{
    String name;
    int age;

    Person(){//无参构造器
        age = 10;
    }
    Person(String pName,int pAge){//有参构造器
        name = pName;
        age = pAge;
    }
}
```

**注意事项**

* 一个类可以定义多个不同的构造器（构造器重载）；
* 如果程序中没有定义构造器，则系统会自动为类生成一个默认无参构造器：`className(){}`；
* 类中一旦自定义了构造器，默认构造器就会被覆盖（此时为了便捷，可以自己定义一个无参构造器用于重载）。



#### **访问修饰符**

访问修饰符用于控制**[类、成员变量、成员方法、构造方法]**使用的范围。

**访问修饰符包括public、protected、默认（不写时）、private**，从左到右访问范围逐渐减小；四种访问修饰符的范围如下：
（1）public：公开级别，表示公开访问；
（2）protected：受保护级别,对**子类和同一个包**中的类公开；
（3）不写：默认级别，只对**同一个包**中的类公开；
（4）private：私有级别，只有类本身可以访问，不对外公开。

**访问范围包括：同类、同包、子类、不同包**，从左到右范围逐渐增大；不同访问范围可以允许的权限如下：
（1）**同一个类下**，允许public、protected、默认、private 的变量或方法进行访问；
（2）**同一个包下**，允许public、protected、默认 的变量或方法进行访问；
（3）**子类下**，允许public、protected 的变量或方法进行访问；
（4）**不同包下**，只允许public 的的变量或方法进行访问。

**注意事项**

* 访问级别只适用于类和类的成员，不适用于局部变量；
* 类只能用默认和public进行修饰；
* 虽然低权限的内容只能限定的范围被访问，但可以通过该范围内的方法取得该内容。**（封装）**



#### **Object类**

object类是类层次结构的根类，每个类都使用Object作为超类。所有程序都实现这个类的方法。



**equals()方法**

equals()是Object的方法，只能判断引用类型；在Object的多个数据类型的子类中常被重写。

==和equals()的不同点：当对两个对象进行操作时，==比较两个对象的地址是否相等，equals()可以比较两个对象的值是否相等（默认也是比较地址）



**hashCode()方法**

返回该对象的哈希码值。Object类定义的hashCode方法会针对不同的对象返回不同的整数。

作用：

1、主要用于提高具有哈希结构的容器的效率

2、两个引用，如果指向的是同一个对象，则哈希值肯定是一样的；如果指向的是不同对象，则哈希值一般是不一样的。

3、 哈希值主要根据地址计算， 不能完全将哈希值等价于地址。

 

**toString()方法**

返回该对象的字符串表示，默认的toString()方法返回值与**对象引用的值**一致。默认返回：**全类名(包名+类名)+@+哈希值的十六进制**。子类往往重写toString方法，用于返回对象的属性信息。

重写 toString 方法后，打印对象或拼接对象（对象引用）时，都会自动调用该对象的 toString 形式。

获取全类名（在类中） ：`getClass().getName();`

获取对象的hashCode并转成16进制：`Integer.toHexString(hashCode())`



**getClass()方法**

返回对象的运行类型。



**finalize()方法**

当垃圾回收器确定不存在该对象的更多引用时，由对象的垃圾回收器调用此方法。当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以**重写**该方法，完成**资源释放**。

什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用  finalize 方法。垃圾回收机制的调用，由系统来决定(即有自己的GC算法)，也可以通过`System.gc()`主动触发垃圾回收机制。

实际开发中，不会运用finalize方法，理解即可。



---



### 三大特性

#### **封装**

封装（**encap**sulation）就是把抽象出的数据（属性）和对数据的操作（方法）封装在一起，数据被保护在内部，程序中的其他部分**只能通过被授权的操作**才能对数据进行操作；

封装的作用：（1）隐藏细节：调用（传入参数）-->方法（连接数据库）；（2）对数据进行验证，保证安全合理

实现步骤：

（1）将属性进行私有化(private)，让外部不能修改属性；

（2）提供一个公共(public)的set方法，用于对属性判断并赋值；也可以通过构造器的方式对属性进行赋值；

（3）提供一个公共的get方法，用于获取属性的值；



#### **继承**

继承可以**解决代码复用**，让编程更加接近人类思维，当多个类存在同样的属性和方法时可以从这些类中**抽象**出父类/基类，在父类中定义**相同的属性和方法**。

子类/派生类只需要通过**extends**声明继承父类，此后子类会自动拥有父类定义的属性和方法。子类最多只能继承一个父类（指直接继承），因此java是**单继承机制**。

基本语法：`class subClass extends superClass{}`

设计基本思想：继承必须满足**子类is父类**的逻辑，不能滥用继承。（父类的构造器完成父类属性的初始化，子类的构造器完成子类属性的初始化。）

继承的作用：（1）提高代码的复用性；（2）提高代码的扩展性和可维护性；



**继承本质**

一个子类对象时，会在方法区加载类信息：先由最顶级父类开始依次加载父类的信息，每个阶层的父类的所有属性（无论是否是重复名称的变量，是否private）都会存入到该对象在堆中的空间；

当创建一个子类对象时，会在方法区加载类信息：先由最顶级父类(Object...)开始依次加载父类的信息，每个阶层的父类的所有属性（无论是否是重复名称的变量，是否private）都会存入到该对象在堆中的空间；

当用**子类对象访问属性(prop/this.prop)**时，遵从以下规则：首先看子类自身是否有该属性，如果有并且可以访问则返回子类的这个属性；如果没有该属性，则看父类是否有该属性，如果有则访问且返回，如果没有则依次向上继续该操作；
当用**super方法**在子类访问父类属性或方法时，**从直接父类往上一级**开始寻找。



**super关键字**

super代表父类的引用，用于访问父类的属性、方法、构造器

语法：

* 访问父类的属性（不能访问private属性）：`super.属性名`；
* 访问父类的方法（不能访问private方法）:`super.方法名(参数列表)`; 
* 访问父类的构造器（只能放在**子类构造器**的**第一句**，且**不能**再使用this(参数列表)）：`super(参数列表)；`
  * 在子类构造器中如果不指定或不写父类的构造器则会自动调用无参构造器：`super();`
  * super方法只能放在构造器的第一行（由于this方法也只能放在第一行，所以两个方法不能共存在一个构造器内）；
  * 如果父类**没有实现无参构造器（只有有参）**，子类必须在构造器的第一行指定使用父类的有参构造器；



**注意事项**

* 子类继承父类所有的属性和方法（包括私有），但父类的私有属性或方法不能在子类中直接访问，可以在父类通过公共的方法间接访问；

* 子类创建相关对象（每创一个）时**自动、必须、最先**调用父类的构造器（从最顶级的父类Object开始，逐步往下调用），也可自定义使用指定的父类构造器完成父类的初始化；  
* java的所有类都是Object类的子类，Object是所有类的基类，因此每次调用类的构造器都会先调用Object的构造器； 
* 当子类和父类有**重名**的属性或方法时，必须使用super访问父类的成员，使用this或直接变量名的方式可访问子类的成员；如果没有重名，则直接访问和super/this效果一致。



#### 多态

多态（polymorphic)是指方法或对象有多种形态。多态建立在封装和继承之上。主要解决代码中复用性不高的问题，复用性不高导致代码维护困难。

多态的体现：（1）方法的多态：重写和重载；（2）对象的多态：是多态的**核心**，对象多态的前提是两个对象是一对继承关系，具体见下。

对象多态的多种写法：

```java
//(1)向上转型和向下转型
Base a = new Sub();//创建一个父类的对象引用a指向子类对象(向上转型)
Sub a_s = (Sub)a;//将父类的对象引用a强转为子类的对象引用a_s（向下转型）
//((Sub)a).method();//可以调用到子类独有的方法, 常代替上一句（向下转型的简化版）
//(2)形参为父类引用，实参为子类引用时常使用
Sub s = new Sub();//创建一个Sub类型的对象s
Base b = s;//将之前创建的Sub对象的地址赋给b，实际就是将父类引用指向子类对象（向上转型）
//(3)修改对象的运行类型（指向另一个子类）
Base a = new Sub1();//创建一个父类的对象引用a指向子类对象(向上转型)
Sub1.method();//指向Sub1s的method
a = new Sub2();//修改animal的运行类型
Sub2.method();//指向Sub2的method
```





**编译类型和运行类型**

编译类型可以理解为编译器(javac)看到的对象的类型，运行类型可以理解为对象真正执行(java)时的类型。**编译类型在对象定义时=号的左边，运行类型在=号的右边**；

例如`Animal animal = new Dog();`	animal的编译类型时Animal，运行类型是Dog。

判断A的运行类型是否是B或B的子类，返回boolean值：`A instanceof B`



**对象的多态（重要）**

**规则：一个对象的编译类型和运行类型可以不一致；编译类型在定义对象时就已经确定，不可改变，而运行类型可以改变。**

体现：**（1）父类的引用可以指向子类的对象（向上转型）；（2）父类引用可以强制转换为子类引用（向下转型）。**



**向上转型**

向上转型的本质：**父类引用**可以指向**子类对象**。

应用场景：需要用一个方法传入多种子类时，可以使用向上转型。

语法：`父类类型 引用名 = new 子类类型();`

调用规则：

* 实现多态向上转型的对象只能调用父类的所有成员（仍需遵守访问权限），而不能调用子类**特有**（子类有父类无）的成员【若要访问需要向下转型】； 

* 在编译阶段，能调用哪些成员是由**编译类型（父类）**决定的，如果一个方法子类有父类无，用父类引用去访问会报错【该条是上一条的原因】；

* 在执行阶段，程序的最终运行效果是由**运行类型（子类）**决定的，即在出现**重写的方法 被调用**时，按照从子类开始向上查找方法。



**向下转型**

向下转型的本质：将**父类引用**强制转换为**子类引用**。

应用场景：当访问的方法为**子类特有**时，需要将父类引用转换为子类引用再调用。

语法：`子类类型 新子类引用名 = (子类类型)父类引用;`

强转规则：

* 只能强转父类的引用，不能强转父类的对象；
* 强转中要求**父类引用**必须指向的是原有目标类型 （向上转型中的子类）的对象；【如果试图将父类引用转换为其他对象，会报ClassCastException错误】
* 当向下转型后，就可以调用子类类型的所有成员（子类也可向上访问到父类）；

e.g. [exercise demo](F:\MyGit\java\basic-app\src\com\hspedu\polymorphic\exercise)

```java
public class demo {
    public static void main(String[] args) {
        Object obj = "hello";//向上转型：将父类引用(obj)指向子类对象（String的"hello")
        String objStr = (String)obj;//向下转型：将父类引用强制转换为子类引用，父类引用指向的String是当前目标类型
        Object objPri = new Integer(5);//向上转型：将父类引用(Object的obj)指向子类对象（Integer的5)
        //String str = (String)objPri;//报错，因为强转过程中父类引用未指向原有的子类对象(Integer)
        Integer str1 = (Integer)objPri;//向下转型：将父类引用(objPri)强制转换为子类引用(str1),父类引用指向的Integer是原有的目标对象
    }
}
```



**java的动态绑定机制（重要）**

当调用对象**方法**的时候，该方法会和该对象的内存地址/**运行类型**绑定；

当调用对象**属性**的时候， 不会触发动态绑定机制，哪里声明就在哪里使用。

e.g. [DynamicBinding demo](F:\MyGit\java\basic-app\src\com\hspedu\polymorphic\DynamicBinding)

```java
public class DynamicBinding {
    public static void main(String[] args) {
        //a 的编译类型 A, 运行类型 B
        A a = new B();//向上转型
        //由于运行类型B中没有sum()，向上寻找后使用父类的sum()；动态绑定机制使得，sum()中的getI()使用运行类型B中的getI()
        System.out.println(a.sum());
        //由于运行类型B中没有sum1()，向上寻找后使用父类的sum1()；属性没有动态绑定，sum()中的i使用就近类型A中的i（在哪用哪）
        System.out.println(a.sum1());
    }
}

class A {//父类
    public int i = 10;
    //动态绑定机制
    public int sum() {//父类sum()
        return getI() + 10;//20 + 10
    }
    public int sum1() {//父类sum1()
        return i + 10;//10 + 10
    }
    public int getI() {//父类getI  
        return i;
    }
}

class B extends A {//子类
    public int i = 20;
    public int getI() {//子类getI()
        return i;
    }
}
```



**多态的应用**

（1）多态数组：数组的定义类型为父类类型，其中的元素为子类类型

e.g. [Ojbect array demo](F:\MyGit\java\basic-app\src\com\hspedu\polymorphic\array)

```java
public class demo {
    public static void main(String[] args) {
        Person[] persons = new Person[5];//对象数组
        persons[0] = new Person("A", 18);//Person有两个属性：name和age
        persons[1] = new Teacher("B",22,30000);//Teacher继承Person,有特有属性salary
        persons[2] = new Teacher("C",23,20000);
        persons[3] = new Student("D",24,100);//Student继承Person，有特有属性score
        persons[4] = new Student("E",25,97);

        for (int i = 0; i < persons.length; i++) {
            System.out.println(person[i].say()};
    }
}
```

（2）参数多态：通过将子类对象引用作为实参传入形参为父类引用的方法中(父类引用指向子类对象)，实现不同类型对象的传入。

e.g. [Master feed animals demo](F:\MyGit\java\basic-app\src\com\hspedu\polymorphic\basic)

e.g. [Empolyee getAnnual demo](F:\MyGit\java\basic-app\src\com\hspedu\polymorphic\parameter)

```java
//e.g.应用（3）
public class PolyTest {
    public static void main(String[] args) {
//        Animal animal = new Dog();//Animal是编译类型 Dog是运行类型
//        animal.cry();//此时运行Dog的cry():运行时，看animal的运行类型决定该行的执行情况
//        animal = new Cat();//修改了animal的运行类型
//        animal.cry();//此时运行Cat的cry()
        Master master = new Master("Tom");
        Cat c = new Cat("喵喵");//Cat继承Animal
        Dog d = new Dog("大黄");//Dog继承Animal
        Beef f1 = new Beef("五花肉");//Beef继承Food
        Pork f2 = new Pork("牛肚");//Pork继承Food
        master.feed(c,f1);//多态的体现：形参为父类引用，实参为子类引用
        master.feed(d,f2);//同上
    }
}

public class Master {
    private String name;
    public Master(String name) {
        this.name = name;
    }
    public void feed(Animal animal, Food food){
        System.out.println("主人" + this.name+"给"+animal.getName() + "喂" + food.getName());
    }
}
```



---



### 面向对象（高级）

#### 基础

##### **类变量**

类变量又称为**静态变量/静态属性**，由static修饰。该变量会被**同一个类的所有对象实例共享**，是该类所有对象共享的变量，任何一个该类的对象访问/修改它时，都是对同一个内存地址存放的变量操作。

**定义**语法：`accessModifier static type staticVar;`	或	`static accessModifier type staticVar;`

**访问**类对象的语法：`className.staticVar`	或	`objectName.staticVar`	(前提是 **满足访问修饰符的访问权限和范围**） 

使用场景：当需要让每个类共享一个变量时，考虑使用类变量。



**类变量注意事项：**

* 类变量是在**类加载**的时候生成和初始化的，即使没有创建对象实例也可以访问；
* 类变量是该类的所有对象共享的，而实例变量（普通属性/非静态变量）时每个对象独享的；
* 类变量的**生命周期**由类的加载开始，随类的消亡而销毁；
* 非静态变量可以接收静态和非静态变量类型返回值方法，而静态变量只能接收静态变量类型返回值方法；



##### **类方法**

java中的方法可以分为**静态方法**和**非静态方法**。静态方法和静态数据成员会随着**类加载**而被分配和装载入内存中，非静态方法和非静态数据成员只有在**类的对象创建时**在**对象的内存中**才有这个方法的代码段。

类方法就是用static修饰的方法。一般Java中工具类里面的工具方法都用static修饰，作为静态方法；

定义语法：`accessModifier static type staticMethod(){}`	或	`static accessModifier type staticMethod(){};`

访问类方法的语法：`className.staticMethod()`	或	`objectName.staticMethod()`	(前提是 **满足访问修饰符的访问权限和范围**） 

使用场景：当方法中不涉及任何和对象相关的成员，则可以将方法设计为静态方法，可以不用创建新对象，提高开发效率。



**类方法注意事项:**

* 类方法的**结构信息**和普通方法一样都存放在**方法区**； 

* 在类方法中访问类变量可以直接写`类变量名`也可以使用`类名.类变量名`（不允许使用this）；

* 静态方法中不允许使用this和super等关键字，而非静态方法中隐藏且可以使用这些关键字；

* 构造器属于非静态方法，都可以访问；用类访问类方法时不会调用构造器，因为没有产生对象；

* **非静态方法既可以**访问静态数据属性/方法**又**可以访问非静态数据属性/方法，而**静态方法只能**访问静态数据属性/方法。

  

##### **main方法**

main方法形式：`public static void main(String[] args){}`

解读：（1）main方法由**java虚拟机(jvm)**调用；（2）必须要求**访问权限**为public以供jvm调用；（3）jvm在执行main()方法时不创建新对象，因此是static修饰的**静态方法**。main方法接收String类型的数组参数在args数组中保存执行java命令时传递给所运行类的参数。

args传入的方式：（1）在命令行传入参数`java className param1 param2 param3...`	（2）Idea传入参数Edit Configurations->Program arguments(用空格隔开各个参数)



**main方法注意事项：**

* **在main()方法下**，可以直接调用**main方法所在类**的**静态成员**，但不能访问该类的非静态成员（要通过创建实例对象，通过对象访问非静态成员）



##### 代码块

代码化块又称为**初始化块**，属于类中的成员。可以分为**静态代码块**和**普通代码块**，都可以看做**另一种形式的构造器**（对构造器的补充机制），可以做初始化操作；

与方法不同的是，代码块没有方法名，没有返回值，没有参数，只有方法体，而且不用通过对象或类显式调用。其在**加载**类或**创建**类时**隐式调用**。

语法：`[修饰符] {代码};`	修饰符可选(static)，代码最后的;可加可不加。

使用场景：如果多个构造器中有重复的语句，可以抽取到初始化块中，提高代码的重用性；

**静态和普通代码块的区别：**
静态代码块是随着**类的加载**进行的，**只会执行一次**； 
而普通代码块是在**创建一个对象时**执行的，实际先执行的是对象的构造器部分，只是构造器的**最前面**隐含着**super()和普通代码块的调用**，因此每创建一个该类对象就执行一次（与类加载无关，所以只使用静态成员普通代码块不会被调用）

子类构造器的隐藏执行：

```java
public A(){
	//(1)调用super();
	//(2)调用普通代码块和普通属性初始化
	初始化代码...
}
```



**发生类加载的时刻（☆）：**（1）使用new创建对象实例时；（2）创建子类实例对象时，父类会被加载；（3）使用类的静态成员时（属性或方法）

**创建对象，在一个类中的调用顺序（☆）**：（1）调用静态代码块和静态属性初始化（两者优先级一致，按定义顺序调用） （2）调用普通代码块和普通属性初始化（两者优先级一致，按定义顺序调用） （3）调用构造方法

产生继承关系时创建子类对象的调用顺序：
（1）父类静态代码块和静态属性；（两者优先级一致，按定义顺序调用）
（2）子类静态代码块和静态属性；（两者优先级一致，按定义顺序调用）
（3）父类普通代码块和普通属性初始化；（两者优先级一致，按定义顺序调用）
（4）父类构造器；
（5）子类普通代码块和普通属性初始化；（两者优先级一致，按定义顺序调用）
（6）子类构造器；



**注意事项：**

* 调用子类的静态成员时，一定会先加载父类（发生代码块的调用）；
* 代码同时含有静态代码块和普通代码块会一起被调用（无论定义先后，都是静态代码块先被调用）；
* 静态代码块只能调用静态成员，普通代码块可以调用任意成员；
* 父类的static方法不可以被子类重写；



##### **final关键字**

final可以修饰**类、属性、方法和局部变量**。由final修饰的属性一般称为常量。final修饰的属性必须**在定义时赋予初值**，并且以后**不能修改**。

使用场景：

（1）不希望**类被继承**时，可以用final修饰类；

（2）不希望父类的某个方法被子类**重写或覆盖**(override)时，可以用final关键字修饰；

（3）不希望类的某个**属性的值被修改**，可以用final修饰；

（4）不希望某个**局部变量被修改**，可以用final修饰；

final变量的赋值位置：（1）在类定义中；（2）在构造器中；（3）在代码块中；















#### 设计模式

设计模式（Design pattern）代表了最佳的实践（在大量实践中总结和理论化之后优选的**代码结构、编程风格**以及解决的问题**思考方式**），通常被有经验的**面向对象**的软件开发人员所采用。



##### 单例设计模式

单例设计模式涉及到一个单一的类，该类负责创建自己的对象，同时**确保只有单个对象被创建**。这个类提供了一种访问其**唯一**的对象的方式，可以直接访问，**不需要实例化**该类的对象。

单例模式可以分为懒汉式和饿汉式两种。



**饿汉式单例模式**

饿汉式是指即使没有使用该类实例，随着类的加载也会创建该类的对象。

创建饿汉式单例模式步骤：

（1）构造器私有化，防止该类被实例化；

（2）类内部创建（私有静态）对象，接收创建的一个对象；

（3）向外暴露一个公共静态方法getInstance()，返回该对象，用于外部直接访问(无论访问几次，都是指向同一个内存地址）；

e.g.:

```java
public class demo {
    public static void main(String[] args) {
        
        SingleTon instance = SingleTon.getInstance();
    }
}

class SingleTon{
    private static SingleTon instance = new SingleTon();//在类内部直接创建对象

    private SingleTon(){}//将构造器私有化，防止该类被实例化

    public static SingleTon getInstance(){//提供公共static方法返回该对象
        return instance;
    }
}
```



**懒汉式单例模式**

饿汉式可能造成创建对象却没有使用，懒汉式可以防止这一问题；

懒汉式只有当用户在main()函数中使用getInstance()才会调用构造器并创建对象。

创建懒汉式单例模式步骤：

（1）构造器私有化，防止该类被实例化；

（2）类内部创建（私有静态）对象；

（3）提供一个公共静态方法getInstance()，可以返回该对象；

e.g.:

```java
public class demo2 {
    public static void main(String[] args) {
        System.out.println(Cat.n1);//在类加载过程中不调用构造器
        Cat instance = Cat.getInstance();
        Cat instance2 = Cat.getInstance();//只调用一次构造器
    }
}

class Cat{
    private String name;
    public static int n1 = 999;
    private static Cat cat;//类内部创建（私有静态）对象

    private Cat(String name){//构造器私有化，防止该类被实例化
        System.out.println("构造器被调用");
        this.name = name;
    }

    public static Cat getInstance(){//提供一个公共静态方法getInstance()，如果对象未被创建则创建该对象
        if(cat==null){
            cat = new Cat("miaomiao");
        }
        return cat;
    }
}
```



**饿汉式和懒汉式的区别：**

（1）两者创建对象的**时机**不同，饿汉式在类加载中创建对象实例，懒汉式是在使用中创建；

（2）饿汉式不存在**线程安全**问题，懒汉式存在线程安全问题；

（3）饿汉式存在**资源浪费**的可能，懒汉式不存在。 





















