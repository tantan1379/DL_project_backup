# 计算机底层原理

## 计算机组成

#### 主要组成部分

电子计算机三大核心部件：CPU、内存、IO设备

<img src="C:\Users\TRT\AppData\Roaming\Typora\typora-user-images\image-20220206184937788.png" alt="image-20220206184937788" style="zoom:33%;" />

**程序运行基本流程**

通过运行某程序，从硬盘加载到CPU中（当程序被加载后，变成一个进程），操作系统找到该进程的”第一行代码“（主线程），逐行发送给CPU，然后由CPU返回给内存。



#### 进程与线程

**进程**是分配资源的基本单位。

**线程**是进程中执行运算的最小单位，是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。

多进程是指操作系统能同时运行多个任务（程序）；多线程是指在同一程序中有多个顺序流在执行。



#### CPU

**作用：**解释计算机指令以及处理计算机软件中的数据。

**主要组成部分：**主要包括**控制器**和**运算器**（ALU）以及**寄存器**（Register），其中还包括**高速缓冲存储器**（Cache）及实现它们联系的数据、控制的总线。

**控制器组成：**由程序计数器（PC）、指令寄存器、指令译码器、时序产生器和操作控制器组成

**名词解释：**

* ALU：算数逻辑运算单元，是一种集多种运算于一体的运算电路。它能按照控制信号的规定执行某种算术或逻辑运算。

* Register：寄存器，用于存储数据。寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据、地址和运算结果。
  * 包括通用寄存器、专用寄存器和控制寄存器。

* Cache：高速缓冲存储器，是进行高速数据交换的存储器，先于内存与CPU交换数据。
  * 工作原理：当CPU要读取一个数据时，首先从CPU缓存（一般采用三级缓存）中查找，找到就立即读取并送给CPU处理；没有找到，就从速率相对较慢的内存中读取并送给CPU处理，同时把这个数据所在的数据块（64Bytes）调入缓存中，可以使得以后对整块数据的读取都从缓存中进行。
* PC：程序计数器，用于存储指令。是CPU中能够具体指出下一条指令的地址的部件。



#### 缓存行

CPU读取内存数据时并非一次只读一个字节，而是会读一段64字节长度的连续的内存块(chunks of memory)，这些块我们称之为缓存行(Cache line)。

在Java 8中，可以采用**@Contended**在**类**级别上的注释，来进行缓存行填充，保证变量存在于单独的一行。这样，可以解决多线程情况下的**伪共享**冲突问题。

**伪共享**

一个缓存行可以被许多线程访问。如果其中一个线程修改了某个变量，那么会导致多个线程都会重新加载整个缓存行。虽然说这些修改逻辑上是互相独立的，但同一缓存行上的数据是统一维护的，一致性的粒度并非体现在单个元素上。这种不必要的数据共享就称之为“伪共享”(False Sharing)。

**填充**

一个CPU核心在加载一个缓存行时要执行上百条指令。如果一个核心要等待另外一个核心来重新加载缓存行，那么他就必须等在那里，称之为`stall`(停止运转)。减少伪共享也就意味着减少了`stall`的发生，其中一个手段就是通过填充(Padding)数据的形式，来保证本应有可能位于同一个缓存行的两个变量，在被多线程访问时必定位于不同的缓存行。



## 并发编程

#### 内存模型概念

计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。

　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：i=i+1

 　　当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。

　　这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。

　　也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。



#### 三大问题

在并发编程中，我们通常会遇到以下三个问题：**原子性问题，可见性问题，有序性问题**。

原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

有序性：即程序执行的顺序按照代码的先后顺序执行。



#### 对象创建过程

底层中：

1、为对象分配空间（半初始化），赋默认值：`new #2 <T>`；

2、运行对象的构造方法，赋初始值：`invokespecial #3 <T.<init>>`；

3、建立关联，将栈上的对象引用指向对象地址：`astore_1`。



#### DCL

DCL（Double Check Lock）双重检查上锁。主要用于防止加锁过程中第二个线程进入锁中的内容。



## 锁

### 简介

我们将锁中的代码称为临界区，被我们当成锁的对象被称为锁对象。任何对象都可以作为锁对象。**我们要注意被锁的是对象而不是代码。**



### 对象的内存布局

对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。  

对象头(Object Header)一般占12个字节的内存，包括两部分信息。

第一部分用于**存储对象自身的运行时数据**， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂 不考虑开启压缩指针的场景）中分别为32个和64个Bits，称它为“Mark Word”。

对象头的另外一部分是类型指针，即是对象指向它的类的元数据的指针，**虚拟机通过这个指针来确定这个对象是哪个类的实例**。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说查找对象的元数据信息并不一定要经过对象本身。



### 锁与内存布局

锁标志位位于对象头中，锁标志位与是否偏向锁对应到唯一的锁状态。

锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。



















