# 多线程

### 线程简介

进程（Process）：进程是程序执行的一次过程，是一个**动态**的概念。是系统资源分配的基本单位，

线程（Thread）：一个进程中可以包含若干个进程。线程是CPU运算调度的基本单位。

多线程：很多多线程是模拟出来的，真正的多线程是指有多个cpu（多核，如服务器）。模拟出来的多线程是在一个cpu的情况下，在同一时间点，cpu只能执行一个代码，只是切换的很快有同时执行的错觉。



**多线程和普通方法的区别：**

普通方法：只有主线程一条执行路径；

多线程：多条执行路径，主线程和子线程**并行交替**执行；



**核心概念：**

* 线程是独立的执行路径；
* 在程序运行时，即使没有自己创造线程，后台也会有多个线程，如主线程，gc线程；
* main()称为主线程，为系统的入口，用于执行整个程序；
* 在进程中，如果开辟了很多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，不能人为干预；
* 对同一份资源操作时，会存在资源抢夺问题，需要加入并发控制；
* 线程会带来额外的开销，如cpu调度时间，并发控制开销；
* **每个线程只能在自己的工作内存交互，内存控制不当会导致数据不一致**



**多线程三要素：**

**原子性：**

指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操作打断，要么就全部不执行。原子性是数据一致性的保障。

解决：synchronized关键字

**可见性：**

指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他线程可以立即看到修改的结果。(线程间的通信实现)

解决：synchronized关键字、volatile关键字

**有序性：**

在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序。

需要满足以下两个条件：（1）在单线程环境下不能改变程序运行的结果；（2）存在数据依赖关系的不允许重排序



### 线程创建

##### **lambda表达式**

Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数。

**具体用法：**对于函数式接口，可以通过lambda表达式创建该接口的对象。（**函数式接口：**任何接口只包含**一个**抽象方法）

e.g.:`new Thread(()->System.out.println("学习")).start();`

**语法：**

（1）(params)->expression

（2）(params)->{statements;}



**说明：**

- lambda表达式用接口类型的对象进行接收，表示对接口中的唯一方法进行实现（如果需要参数需要添加参数）
- 可选类型声明：不需要声明参数类型（要去除就都去除），编译器可以统一识别参数值。
- 可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。
- 可选的大括号：如果主体只包含了一个语句，就不需要使用大括号。
- 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。



**优势：**

* 避免匿名内部类定义过多
* 简化代码，只留下核心逻辑



##### **三种方式**

（1）继承Thread类【声明为Thread的子类，并重写run类】（重点）

（2）实现Runnable接口【重写run类的T】（重点）

（3）实现Callable接口（了解）



**方式一、继承Thread类**

**过程：**

* 自定义线程继承Thread类；
* 重写run方法，编写线程执行体；
* 创建线程对象，调用start()方法启动线程。（注意：调用start方法会自动调用重写的run方法）



demo:

```java
public class TestThread1 extends Thread{
    @Override
    public void run() {
        //run方法线程体
        for (int i = 0; i < 20; i++) {
            System.out.println("Thread线程"+i);
        }
    }

    public static void main(String[] args) {
        //主线程
        //线程开启不一定立即执行，由CPU调度执行；
		//多线程和主线程并行交替执行
        TestThread1 testThread1 = new TestThread1();//创建线程对象
        testThread1.start();//调用start方法开启线程

        for (int i = 0; i < 1000; i++) {
            System.out.println("主线程"+i);
        }

    }
}
```



**方式二、实现Runnable接口**

**过程：**

* 自定义线程实现Runnable接口；
* 重写run方法，编写线程执行体；
* 创建线程对象，创建Thread对象并作为参数传递，调用start()方法启动线程，可以传入同一个线程。（注意：调用start方法会自动调用重写的run方法）



demo:

```java
public class TestThread4 implements Runnable{
    private int ticketNum = 10;

    public void run() {
        while(true){
            if(ticketNum<=0){
                break;
            }
            System.out.println(Thread.currentThread().getName()+"拿到了第"+ticketNum--+"张票");
        }
    }

    public static void main(String[] args) {
        TestThread4 tt = new TestThread4();
        new Thread(tt,"a").start();//Thread第二个参数可以为线程取名
        new Thread(tt,"b").start();
    }
}
```

**说明：**

* Thread第二个参数可以为线程取名
* `Thread.currentThread()`取得当前的线程，`Thread.currentThread().getName()`取得当前的线程名



**方式三、实现Callable接口**

**过程：**

* 实现Callable接口，需要返回值类型
* 需要重写call方法并抛出异常
* 创建目标对象：`TestCallable t1 = new TestCallable();`
* 创建执行服务：`ExecutorService ser = Executors.newFixedThreadPool(1);`
* 提交执行：`Future<Boolean> result1 = ser.submit(t1);`
* 获取结果：`boolean r1 = result1.get();`
* 关闭服务：`ser.shutdown();`



demo:

```java
public class TestCallable implements Callable<Boolean> {

    //加载图片线程的执行体
    @Override
    public Boolean call() {
        System.out.println("下载完成");
        return true;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        TestCallable t1 = new TestCallable();
        TestCallable t2 = new TestCallable();
        TestCallable t3 = new TestCallable();
        
        //创建执行服务
        ExecutorService ser = Executors.newFixedThreadPool(3);//创建线程池
        //提交执行
        Future<Boolean> result1 = ser.submit(t1);
        Future<Boolean> result2 = ser.submit(t2);
        Future<Boolean> result3 = ser.submit(t3);
        //获取结果(返回值）
        boolean r1 = result1.get();
        boolean r2 = result2.get();
        boolean r3 = result3.get();

        //关闭服务
        ser.shutdown();
    }
}
```



**三种方式比较**

**（1）继承Thread类**

- 子类继承Thread类就可以具备多线程能力
- 启动线程：`子类对象.start()`
- 不建议使用，因为OOP是单继承，同一个对象不能被多个线程使用



**（2）实现Runnable接口**

- 子类实现Runnable接口并重写run方法可以具备多线程能力
- 启动线程：`Thread对象(实现类对象).start()`
- 建议使用，灵活方便，同一个对象可以被多个线程使用（多代理）



**（3）实现Callable接口**

* 子类实现Runnable接口并重写call方法可以具备多线程能力
* 启动线程：创建执行服务+提交执行+获取结果
* Runnable 没有返回值，Callable 有返回值，Callable 可以看作是 Runnable 的补充



### 代理

**静态代理**

真实对象和代理对象实现同一个接口，代理对象要代理真实角色（设置真实角色的属性并传入）。

**优势：**代理对象可以做真实对象做不了的事，真实对象可以专心做自己的事

demo:

```java
public class TestSP {
    public static void main(String[] args) {
        WeddingCompany weddingCompany = new WeddingCompany(new You());
        weddingCompany.HappyMarry();
    }
}

interface Marry{
    void HappyMarry();
}

//真实角色结婚
class You implements Marry{
    @Override
    public void HappyMarry() {
        System.out.println("我要结婚了，很开心！");
    }
}

//代理角色，帮助结婚
class WeddingCompany implements Marry{
    private Marry target;


    public WeddingCompany(Marry target) {
        this.target = target;
    }

    @Override
    public void HappyMarry() {
        before();
        this.target.HappyMarry();
        after();
    }

    private void after() {
        System.out.println("结婚之后收尾款");
    }

    public void before(){
        System.out.println("结婚前布置现场");
    }
}
```



### 线程状态

java中用`Thread.state`表示线程当前的状态。

线程状态包括：创建状态(New)、就绪状态(Ready)、运行状态(Runnable)、阻塞状态(Blocked)、死亡状态(Terminated)



**过程：**

* 当线程对象被创建时，线程进入**创建状态**(New)
* 当调用start方法，线程立即进入**就绪状态**，等待调度执行(Ready)
* 当调用sleep、wait或同步锁时，线程进入**阻塞状态**(Blocked)；阻塞解除后，重新进入就绪状态等待cpu调度执行；
* cpu对线程进行调度执行，线程进入**运行状态**(Runnable)；
* 线程中断或结束，线程进入**死亡状态**(Terminated)，处于终止态的进程不再被调度执行



demo:

```java
public class TestState {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(()->{//创建进程
            for (int i = 0; i < 5; i++) {
                try {
                    Thread.sleep(1000);//阻塞
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("//////");
        });
        Thread.State state = thread.getState();//(New)
        System.out.println(state);
        thread.start();//启动线程,进入预备状态
        state = thread.getState();//(Runnable)
        System.out.println(state);
        while(state != Thread.State.TERMINATED){//当阻塞状态结束，终止进程(TERMINATED)
            Thread.sleep(100);
            state = thread.getState();//(TIMED_WAITING)
            System.out.println(state);
        }
    }
}
```





### 线程方法

**停止线程**

废弃：stop()、destroy()

一般使用一个标志位作为终止变量：

```java
public class TestStop implements Runnable{
    private boolean flag = true;

    @Override
    public void run() {
        int i = 0;
        while(flag){
            System.out.println("run Thread"+i++);
        }
    }

    public void stop(){
        flag = false;
    }

    public static void main(String[] args) throws InterruptedException {
        TestStop testStop = new TestStop();
        new Thread(testStop).start();
        Thread.sleep(10);//防止分线程未执行主线程就将flag置false
        for (int i = 0; i < 1000; i++) {
            System.out.println("main"+i);
            if(i==900){
                testStop.stop();
                System.out.println("该线程停止");
            }
        }
    }
}
```



**线程休眠**

**语法：**`Thread.sleep(time)`

**说明：**

* sleep(time)指定当前线程组成的毫秒数；
* sleep使用时需要抛出相关异常（InterruptedException)
* sleep时间到达后线程进入就绪状态；
* sleep可以模拟网络延时，倒计时等=>放大问题的发生性；
* **每一个对象都有一把锁，sleep不会释放锁**



**线程礼让**

**语法：**`Thread.yield()`

**作用：**

（1）礼让线程，让当前执行的线程暂停，但不阻塞；

（2）此时线程会从运行状态转为就绪状态；

（3）**让cpu重新调度，礼让不一定成功，看CPU分配情况。**



demo:

```java
public class TestYield {
    public static void main(String[] args) {
        MyYield myYield = new MyYield();
        new Thread(myYield,"a").start();
        new Thread(myYield,"b").start();
    }
}

class MyYield implements Runnable{

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"线程开始执行");
        Thread.yield();
        System.out.println(Thread.currentThread().getName()+"线程结束执行");
    }
}
```



**线程合并**

**语法：**`thread.join()`	注意，此处的thread是进程对象

**作用：**用于合并线程，当此线程执行完成后，再执行其他线程，其他线程阻塞(插队)

demo:

```java
public class TestJoin implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println("vip-"+i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        TestJoin testJoin = new TestJoin();
        Thread thread = new Thread(testJoin);
        thread.start();

        //主线程
        for (int i = 0; i < 500; i++) {
            if(i==200){
                thread.join();
            }
            System.out.println("main-"+i);
        }
    }
}
```



**设置优先级**

**语法：**

`Thread.currentThread().getPriority()`	显示当前进程的优先级

`thread.setPriority(PRIORITY)`	设置优先级





### 守护线程

线程分为用户线程和守护线程。

虚拟机必须确保用户线程执行完毕，不用等待守护线程执行完毕。

守护线程包括比如后台记录操作日志、监控内存、垃圾回收机制。

语法：`thread.setDaemon(true);`	设置某个线程为守护线程（默认为false，表示用户线程）



### 线程安全

方式：线程同步

场景：并发（同一个对象被多个线程同时操作）

线程同步是一种等待机制，多个需要同时访问此对象的线程进入**这个对象的等待池**形成队列，等先前的线程使用完毕下一个线程再使用。

**总结：**

- 方法一：使用安全类。
- 方法二：使用自动锁 synchronized。
- 方法三：使用手动锁 Lock。



**队列和锁**

每个对象都拥有一把锁。

由于同一进程的多个线程共享同一块存储空间，在带来方便的同时也会带来访问冲突问题。为了保证数据在方法中被访问时的正确性，在访问时需要加入锁机制 (synchronized)，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可。

**主要问题：**

- 一个线程持有锁会导致其他所有需要此锁的线程挂起，降低效率；
- 在多线程竞争下，加锁、释放锁会导致较多的上下文切换和调度延时，引起性能问题；
- 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题；



##### synchronized同步

**同步方法**

**语法：**`public synchronized void method(args){}`

**说明：**synchronized方法控制对**”对象“**的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程阻塞，方法一旦执行就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得该锁继续执行。



**同步块**

**语法：**`synchronized(obj){}`

obj称为同步监视器。

**说明： **

- Obj可以是任何对象，但是推荐使用**共享资源**作为同步监视器
- 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，或者是class.

**同步监视器的执行过程：**

* 第一个线程访问，锁定同步监视器，执行代码；
* 第二个线程访问，发现同步监视器被锁定，无法访问；
* 第一个线程访问完毕，解锁同步监视器；
* 第二个线程访问，锁定，重复；



##### **Lock锁**

lock锁通过显示定义同步锁对象实现同步。

所属包：`java.util.concurrent.locks.Lock`

Lock接口是控制多个线程对共享资源访问的工具。锁提供了对共享资源的独占空间，每次只能有一个对象对Lock对象加锁，线程开始访问共享资源前应该先获得Lock对象。

**ReentrantLock类**实现了Lock接口，拥有和synchronized相同的并发性和内存语义。在实现线程安全控制中，比较常用的是ReentranLock，可以显式的加锁、释放锁。



synchronized和Lock对比：

- Lock是显式锁（需要手动开关），synchronized是隐式锁，退出作用域会自动释放；
- Lock只有代码块锁，synchronized有代码块锁和方法锁两种
- 使用Lock锁，JVM花费较少的时间调度线程，性能更好，有更好的扩展性



##### **死锁**

多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或以上的线程都在等待对方释放资源，都停止执行的情形。

同一个同步块同时拥有**两个以上对象的锁**，就可能发生死锁问题。



产生的四个必要条件：

- 互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
- 请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但又对自己获得的资源保持不放
- 不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放
- 环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系



### ThreadLocal

ThreadLocal全称线程局部变量，主要解决多线程中数据因并发产生不一致问题。ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。耗费了内存，但大大减少了线程同步所带来性能消耗，也减少了线程并发控制的复杂度。



**底层原理**

每个线程都要自己的一个map，map是一个数组的数据结构存储数据，每个元素是一个Entry，entry的key是threadlocal的引用，也就是当前变量的副本，value就是set的值。

1、Thread类中有变量threadLocals，类型为ThreadLocal.ThreadLocalMap，保存着每个线程的私有数据。

2、ThreadLocalMap是ThreadLocal的内部类，每个数据用Entry保存，其中的Entry继承于WeakReference，用一个键值对存储，键为ThreadLocal的引用。如果是强引用，即把ThreadLocal设置为null，GC也不会回收，因为ThreadLocalMap对它有强引用。

3、ThreadLocal中的**set方法**的实现逻辑，先获取当前线程，取出当前线程的ThreadLocalMap，如果不存在就会创建一个ThreadLocalMap，如果存在就会把当前的threadlocal的引用作为键，传入的参数作为值存入map中。

4、ThreadLocal中**get方法**的实现逻辑，获取当前线程，取出当前线程的ThreadLocalMap，用当前的threadlocak作为key在ThreadLocalMap查找，如果存在不为空的Entry，就返回Entry中的value，否则就会执行初始化并返回默认的值。

5、ThreadLocal中**remove方法**的实现逻辑，还是先获取当前线程的ThreadLocalMap变量，如果存在就调用ThreadLocalMap的remove方法。ThreadLocalMap的存储就是数组的实行，因此需要确定元素的位置，找到Entry，把entry的键值对都设为null，最后也Entry也设置为null。



### 线程通信

**生产者消费者模式**

**作用：**

（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用

（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约

通信方法：

`wait()`		表示线程一直等待，会释放锁（`wait(timeout)`指定等待秒数）

`notify()`	唤醒处于等待的线程

`notifyAll()`	唤醒同一个对象上所有调用wait()方法的线程（优先级高的优先调度）



**并发协作模型（管理法）**

- 生产者：负责生产数据的模块
- 消费者：负责处理数据的模块
- 缓冲区：消费者不能直接使用生产者的数据，需要有缓冲区。生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据。



**信号灯法**

- 设置一个标志位flag，如果为true，就让线程等待、如果为false，就让该线程去通知另一个线程、把两个线程衔接起来，就像咱们的信号灯红灯停，绿灯行，通过这样一个判断方式，只要来判断什么时候等待，什么时候将他唤醒。



### 线程池

**背景：**我们经常创建和销毁、使用量很大的资源，比如并发情况下的线程。

**思路：**提前创建好多个线程，放入线程池中，使用时直接获取，使用后放回池中。可以避免频繁创建销毁、实现重复利用。

**作用：**

- 提高响应速度（减少了创建新线程的时间）
- 降低资源消耗（重复利用线程池中的线程，不用每次都创建）
- 便于线程管理

**属性：**

- corePoolSize：线程池大小
- maximumPoolSize：最大线程数
- keepAliveTime：线程没有任务时最多保持多长时间后会终止

**创建线程池的方式：**



**方法：**

`void executor(Runnable command)`	执行任务，没有返回值

`Future submit(Callable<T> task)`	执行任务，有返回值

`void shutdown()`	关闭线程池



# 反射

### 反射机制







### Class类







### 类加载







### 反射获取类的结构信息







### 反射相关类







### 反射调用性能优化







### Class类常用方法



