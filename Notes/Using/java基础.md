# JAVA基础

### 概述

java优势：最为流行最为广泛；可移植性好、安全可靠、性能较好；开发社区完善，功能丰富。

java应用：桌面应用开发（idea、税务管理软件等）、**企业级应用开发**（微服务、大型互联网应用）、移动应用开发（android、医疗设备）、服务器系统开发（应用后台）、大数据开发（hadoop）、游戏开发等。（行业覆盖率达91%）

java技术体系平台：JAVA SE标准版（核心和基础，用于开发**桌面级应用**，需求量较小）、JAVA EE企业版（多用于**大型网站开发**，是学习的重点）、JAVA ME（用于嵌入式设备技术）、Java Card

java特性：一次编译处处可用，java程序通过javac编译为class文件后，通过各平台的JVM虚拟机均可执行。



下载java后，在bin文件夹中会有两个关键程序：**java为执行工具，javac为编译工具**。

JVM：java虚拟机，是运行java程序的地方。

JDK：java开发工具，包括编译器、虚拟机以及java内置的功能。最常用的版本为JDK8.0，未来会发展JDK11.0作为稳定的平台。【安装JDK时会包含java、javac、jvm和核心类库等java开发运行环境，JDK会关联JRE。】

JRE：java运行环境，JRE可以让计算机系统运行java应用程序；内部包含一个java虚拟机和一些标准的类别函数库。【JRE只包含java、jvm和核心类库等java运行环境。（不含javac）】



**内存图**

java将内存区域划分为：**栈、堆、方法区**、本地方法栈、寄存器

方法区：字节码(class)文件加载时进入的内存、常量池存放位置

栈内存：方法运行时进入的内存（包括变量）、还可以存放基本数据类型的局部变量

堆内存：new的对象在堆内存中开辟空间并产生地址（首先在堆中开辟空间，将产生的地址赋值给栈中的对象，栈保存着该引用对象在堆中的地址）



**注意事项**

* javac编译java源文件(.java)后，会产生字节码文件(.class)；使用java命令执行时，不需要带class

* 使用javap可以将字节码文件**反编码**成一个类[-c 显示汇编代码]

* 旧版本的JDK安装时的PATH需要自己设置，环境变量设置：（文件资源管理器中）此电脑-属性-高级系统设置-高级-环境变量，一般设置两个环境变量：JAVA_HOME：jdk安装位置          Path：JDK的java/javac的安装位置（bin）[%JAVA_HOME%/bin]

* System、String在JDK的Java.lang包下，是默认的包，不需要导入

* **java常用包**：`java.lang.*`（基本包**【系统默认导入】**，包含Integer、String等数据类型类）`java.utils.*`（系统提供的工具包，包含Scanner等）




### Tips

**易错：**

* &&和||要求先满足左边的才能判断右边；



**习惯：**

* 判断语句中?:   &&   ||前后的两个条件可以不加括号，因为优先级一般较低；
* 数组参与的问题需要考虑代码健壮性：数组长度是否为0（for循环无法使用）、数组是否为null



**知识：**

* 获取pi的方法：`Math.PI` 
* 比较字符串大小：`a.compareTo(b)`；判断String是否相等：`.equals()`；



---



# IDEA特性

### 特性

**基础**

**项目结构**：工程(Project)-模块(Module)-包(Package)-类(Class)

IDEA的**源码文件（java文件）**被保存在project的**src**文件夹下。当java文件被运行，会首先被编译为.class文件再运行。**class文件**被存放在project下自动创建的**out**文件夹下。



**包(package)**

package的本质是用不同文件夹存放源文件。源文件**必须**在**最开头**写出自己所在的包：`package packageName;` 

**导入不同包下的类**：`import otherPackage.类名;`，此时可以用`类名`默认的指代该类。（如果不导入外部的类，也可在创建对象时指定（麻烦）：`otherPackage.类名 object = new otherPackage.类名();`）

**命名规则**：只包含数字、字母、下划线和小圆点，不能以数字开头，不能有关键字。**(如果未满足则创建的包会变为普通的文件夹，无法创建class文件！**）

**一般格式：**小写字母+小圆点，如com.公司名.项目名.业务模块名

**注意事项**：(1) 同一个package下不允许有两个同名的源文件；(2) 即使两个包不同也不可以**导入**类名相同的类；(3) 同一个源文件只能有一个类是public的，同一个工程下的其他程序可以调用该类；



**注意事项**

* 使用IDEA自带的导入模块功能，会关联导入原目录的文件，一旦原目录的文件被删除，导入的包也会删除。所以我们建议自己创模块，复制其中的包即可；

* IDEA删除模块时，在菜单中remove只会将模块移除project，而不会删除源文件，要在左上角右键delete；在文件管理器中删除模块不能删干净，要在.idea的modules.xml中进行修改，再重启idea；

  

### 效率

**快捷键**

**alt+enter	快速解决错误（创建方法、抛出异常等）**

**ctrl+i	快速输入重写（主要用于实现类）**

**alt+insert	生成构造器、扩展、等**

ctrl+d 复制当前行

ctrl+x 剪切当前行（替换ctrl+y)

ctrl+alt+l	格式化代码

ctrl+/	注释代码

ctrl+b	定位到方法的定义（ctrl加鼠标左键也行）

ctrl+h	查看层级关系（继承）

ctrl+j	查看live template

tab	自动补全代码也可将类需要的包自动导入

ctrl+enter 相当于enter后仍定位在原来位置

shift+enter 在下一行加行并定位在添加位置

ctrl+alt+enter 在前一行加行并定位在添加位置



**快捷输入**

**main**	->	public static void main(String[] args) {}

**sout**	->	System.out.println();

**content.sout**	->	System.out.println(content);

**array.fori**	->	for (int i = 0; i < array.length ; i++) {}

**fori**	->	for (int i = 0; i < ; i++) {}

**new Class().var**	-> Class 对象名 = new Class();

**Class.getInstance().var** -> Class 对象名 = Class.getInstance();

**itit**	->	while(iter.hasNext()){ Object next = iterator.next();}



### 断点调试

断点调试是指在程序中的某一行设置断点，程序运行到该行就会停止。在断点调试过程中，是以对象的**运行类型**来执行的。

**快捷键：**

F7：跳入（跳入到方法内）

alt+shift+F7：强制跳入方法（可以进入到方法更深的位置）

F8：跳过（逐行执行代码）

shift+F8：跳出（跳出当前所在的方法）

F9：resume（执行到下一个断点【我们可以在运行过程中动态添加断点，用于跳过循环等】）



**具体细节：**

* 代码高亮部分为执行当前位置，此时如果该行有方法，可以使用“跳入”进入该方法。

* Console为输出控制台，可以显示代码的输出情况，也可以进行输入操作；Debugger用于追踪代码的运行流程。
* 将光标放在变量上，可以看到最新的数据。



### JUnit

JUnit是java语言的单元测试框架，主要用于单独测试某个方法。

**使用流程：**

(1) 在需要测试的方法前一行输入@Test；

(2) 输入alt+enter，选择JUnit的版本（5.4.2常用）下载相应的Library；

(3) 直接对某个方法进行运行或调试；

**注意事项：**

* 测试单元中的每个方法一定要能够独立测试，其方法不能有任何依赖。



### 功能

(1) 在类中右键可以查看类的例图(diagram)，可以查看类之间的关系，implement和extend情况。实现表示继承，虚线表示实现；

(2) 修改主函数args的输入：Edit Configurations->Program arguments(用空格隔开各个参数)；

(3) 自动生成的`equals()`和`hashCode()`需要自己选择fields，fields会决定哪些值相同equals()判断为true，哪些值相同hashCode()会返回相同的hashcode值；



### 异常字典

(1) Content of collection are updated, but never queried.

原因说明：向这个集合里面添加元素，而并没有相对应的取出的操作，或者没有返回该集合；

解决办法：进行集合读取的方法，如get()方法。





---



# 基础知识

### 数据

**字面量**

字面量包括整型、小数、字符（必须使用单引号，有且只有一个字符）、字符串（必须使用双引号，内容可有可无也可为单字符）、布尔值（true/false)、空值（null)



**变量**

变量在定义是可以没有初始值，但在使用时必须有；变量的有效范围从定义开始到“}”截止，同一范围不能定义两个相同的变量



**数据类型**

数据类型分为引用数据类型和基本数据类型，引用类型的变量存放的是数据在内存中的地址。基本数据类型的变量则存放数据本身，类型包括byte、short、int、long、float、double、char、boolean 8种。
byte(-128~127)，占1个字节；short(-32768~32767)，占2个字节；int，占4个字节；long，占8个字节；
float，占4个字节；double，占8个字节；char，占2个字节；boolean，占1个字节。

**注意：**java中单引号只能用于单个字符，用char修饰；双引号可以用于单个或多个字符时，用String修饰。



**关键字和标志符**

关键字是java内置的一些单词，不能用作类名或变量名；

标志符适用于给类、方法、变量起名的规矩。要求：不能以数字开头、区分大小写、不能是关键字。

命名规范（驼峰模式）：变量首字母小写，类名首字母大写。



**基本数据类**

int/double/long等都是java预定义的数据类型，Boolean、Character、Byte、Short、Integer、Long、Float、Double则是java.lang包（无需import）里定义的类，是Number的子类，包装了基本数据类型，包含多种功能。

* Number的子类作为返回值可以返回null；
* 用值接受子类返回值类型的结果时也要用对应的类来接收；
* `.MAX_VALUE`和`.MIN_VALUE`可以得到相应类型的最大和最小值；
* `.toString()`可以将类型转换为String。





### **类型转换**

* 变量的自动类型转换

 当不同类型的变量赋值给其他类型的变量时会发生自动类型转换，类型范围小的变量可以直接赋值给类型范围大的变量。（byte->short->int->long->float->double 右边可以兼容左边）

* 表达式的自动类型转换

在表达式中，**小范围类型的变量会自动转换成叫大范围的类型再运算**（byte/short/char->int）。表达式的最终结果类型由表达式的最高类型决定。

* 强制类型转换

`数值类型 var1 = (数值类型)var2`

**当类型范围大的数据赋值给类型范围小的变量时**，需要使用强制类型转换，容易造成数据（丢失）溢出。当我们将浮点型强转为整型时，会丢弃小数部分，保留整数部分返回。

```java
double d = 13.4;
long l = (long)d;//double比long的范围更大，大范围的数据可以转换为小范围的数据
int in = 5;
//boolean b = (boolean)in;//报错，int无法转为boolean，如需要转换使用三目运算符
```



### 运算符和其优先级

**运算符**

* 基本运算符

  在java中两个整数相除，得出的是商**向0取整**的值。如果要保留小数，可以在被除数上乘以1.0。
  **+符号在字符串运算时用作连接符；与python不同，java中可以直接将数据与字符串相加，但当遇到数字首先与单个字符相加时，会得到数字与ascii的加和值。**

* 自增自减运算符

  ++/--放在变量前，会先做自增自减，再对变量值进行运算；放在变量后，先计算再对变量自增自减。

  

* 赋值运算符

  扩展赋值运算符：+= -= *= /= %=，其中均隐含了强制类型转换。

  

* 关系运算符

  ==既可以判断基本类型又可以判断引用类型：

  判断基本类型时，判断值是否相等；判断引用类型时，判断地址是否相等（是否是同一个对象）【当遇到向上转型情况时，依旧看其地址是否指向堆中的同一内存】

  

* 逻辑运算符

  & 逻辑与    | 逻辑或    ! 逻辑非    ^ 逻辑异或
  && 短路与：左边为false则右边不执行    || 短路或：左边为true，右边不执行

  

* 三元运算符

  `条件表达式?value1:value2`    条件表达式不需要加括号    



**优先级**

一般而言，单目运算符优先级较高，赋值运算符优先级较低。算术运算符优先级较高，关系和逻辑运算符优先级较低。多数运算符具有左结合性，单目运算符、三目运算符、赋值运算符具有右结合性。

<img src="C:\Users\TRT\AppData\Roaming\Typora\typora-user-images\image-20211203111329317.png" alt="image-20211203111329317" style="zoom:50%;" />





### 常用接口

**键盘录入技术**

API（应用程序编程接口）：Java写好的程序（功能代码）。

```java
Scanner scan = new Scanner(System.in);
String str1 = scan.next();
int num = scan.nextInt();
```



**产生随机数**

```java
Random rand = new Random();
int randomNumber = rand.nextInt(50)+1;//(1-50)	注意，nextInt(bound)方法会产生[0,bound)范围的数字，左闭右开
```



### **程序流程控制**

**for loop语句**

语法格式:	`for(初始化语句;循环判断条件;循环变量迭代){循环操作}`

**for循环细节：**

* 循环判断条件是一个返回boolean的表达式，如果为true则继续执行循环操作，否则退出；
* for循环在初始化后直接进行条件判断，之后每次执行完当前循环是先对循环变量进行迭代之后，然后再判断是否满足判断条件；
* for第三要素，初始化和变量迭代可以省略（写在for前和循环内部），但“;”和判断条件不能省略；
* 循环初始值可以有多条语句，但要求类型一样，中间用逗号隔开；循环变量迭代也一样。

* 知道循环次数用for，知道循环中止情况使用while。`while(true)`和`for(::)`都可完成死循环，一般使用`while(true){}`完成死循环。



**switch case语句**

语法格式：

```java
switch(expression){
    case value :
       //语句
       break; //可选
    case value :
       //语句
       break; //可选
    //你可以有任意数量的case语句
    default : //可选
       //语句
}
```



---



# 数组

### 基本概念

数组元素可以是任何类型（只要所有元素具有**相同**的类型）。数组元素可以是**基本数据类型**，数组元素也可以是**类对象**，称这样的数组为对象数组，在这种情况下，数组的每一个元素都是一个对象的引用。

**注意事项**

* 如果访问元素索引大于最大索引，执行会出现**数组索引越界异常**(ArrayIndexOutOfBoundsException) ；
* 如果数组变量中没有存储数组的地址，而是null，在访问数组信息时会出现**空指针异常**(NullPointerException)



### 一维数组

**静态初始化数组**

静态初始化**直接赋值**。

定义方法1：`数值类型[] 数组名 = new 数值类型[]{*elements};`	注意在[]中不用写数组长度，由编译器自动判断；

定义方法2（简化）：`数值类型[] 数组名 = {*elements};`	[]可以写在数组名后；

数组长度：`数组名.length`

数组索引：`数组名[0]`

数组变量名中存储的是数组在内存中的地址，因此数组是**引用类型**。直接打印数组时，输出结果表示数组存放的地址。	e.g.[D@4c873330 	[表示数组，D表示数组为double类型，@表示在..地方，4c873330表示该数组的16位地址。



**动态初始化数组**

动态初始化**先定义后赋值**，定义后数组的类型和长度固定，各元素有一个默认值。	

定义格式：`数值类型[] 数组名 = new 数值类型[arrayLength];`	

默认值：int:0 	float:0.0 	string:null	boolean:false

数组拷贝:

```java
//独立拷贝
int[] arr1 = {10,20,30};//静态初始化
int[] arr2 = new int[arr1.length];//动态初始化
for(int i=0;i<arr1.length;i++){
	arr2[i]=arr1[i];
}
//引用拷贝（互相影响）
int[] arr2=arr1;
```

数组翻转：

```java
// 在原数组翻转
int[] arr = {11,22,33,44,55,66};
for (int i = 0; i < arr.length/2; i++) {//注意java中整数/整数，得到的值为商向0取整的值;因此如果arr.length为奇数，则相当于i<(arr.length-1)/2
    int temp = arr[arr.length-1-i];
    arr[arr.length-1-i] = arr[i];
    arr[i] = temp;
}
//创建新数组逆序赋值
int[] arr2 = new int[arr.length];
for(int i=arr.length-1,j=0)
```



**对象数组**

对象数组的每一个元素都是一个对象的引用；

创建语法：`类名[] 数组名 = new 类名[arrayLength]; `



**内存布局**

数组名表示该数组存放的地址，该地址存放着每一行的地址，每个地址又存放构成各行的元素。



### 二维数组

定义格式：`数值类型[][] 数组名 = {{},{},{}...};`	或	`数值类型[] 数组名[] = {{},{}...};`

动态初始化：`数值类型[][] 数组名 = new 数值类型[arrayLength_y][arrayLength_x];`(定义后二维数组的类型和长度固定，各元素有一个默认值)

遍历二维数组：

```java
for (int i = 0; i < array.length; i++) {
    for (int j = 0; j < array[i].length; j++) System.out.print(array[i][j]+" ");
}
```

二维数组可以只确定行，但每个一维数组均需要重新创建空间：

```java
int[][] array = new int[3][]；
for(int i=0;i<array.length;i++){
	arr[i] = new int[i+1];
	for(int j=0;j<array[i].length;j++){
		arr[i][j] = i+1;
	}
}//array:{{1},{2,2}，{3,3,3}}
```



---



# 方法

### 基本概念

方法是一种语法结构，可以把一段代码封装成一个功能，以便重复调用。

**方法的定义和调用**

定义：`访问修饰符 返回值类型 方法名(形参列表){code;	return 返回值;}`

调用：`方法名();`

**注意事项：**

* 方法和方法之间为平级关系，不可嵌套定义，但都是先调用main方法；类则可以，在类内部的类被称为**内部类**；

* 普通方法可以和类名相同，此时它和构造方法唯一的区别就在于有返回类型；

* 同一类的方法直接调用；跨类方法的调用（此时要看方法的访问修饰符），要先创建对象；

* （特殊情况）当成员方法的形参为一个对象时，在方法中将对象置为null，此时不影响实参的对象。因为只改变了额外创建栈空间中的对象的地址，没有修改堆中存放的类本身和主调方法中的对象地址



### 调用

**内存布局**

方法在没有被调用时，在方法区的字节码文件中存放；

方法被调用时，就会在主调方法外开辟一个独立空间（**栈空间**）【所有方法都存放在栈中】；当方法执行完毕或执行到return语句后就会**返回到调用的位置**。



**参数传递**

值传递（形参为基本类型）：在传输基本类型的实参给方法的形参的时候，并不是传输实参本身，而是传输实参变量中数据值。此时被调用的方法会在栈中新开辟一个空间，形参只在该空间内有效，而不能影响实参本身。

引用传递（形参为引用类型【数组、对象、字符串】）：在传输引用类型的实参给方法的形参的时候，传递的是引用类型变量在堆中存放的地址，此时不管是发起调用的方法还是被调用的方法都访问堆中的同一个空间。（在新的栈空间中会创建一个新的实参指向形参所指向的地址）



**递归调用**

递归需要有基线条件，不然会成为死循环

每次递归调用原方法时都会创建一个新的独立空间（栈空间），变量只在栈空间内有效； 



**返回值**

* 返回值类型为void时，可以没有返回值，也可以return关键词单独成行，单独成行可以立即结束当前方法的执行；

* 如果方法要求有返回值类型，则必须与return的值类型一致或兼容（兼容指return后变量的范围小于返回值类型范围）；

* 有返回值的方法调用时可以定义变量接受结果 也可以 单独成行，无返回值方法的调用只能单独成行；

* 一个方法最多只能有一个返回值，但返回值可以是任意类型（基本、引用），因此我们可以通过返回数组返回多个值。



### 重载

重载（overload）是指同一个类中，出 现多个方法名称相同，但**形参列表不同**的**（形参的个数、类型、顺序不同【顺序指形参类型的顺序】）**，这些方法就是重载方法。

优势：可读性好（根据形参实现功能差异化的选择）

注意事项：(1) 访问修饰符、返回值不能作为重载的条件；(2) 形参名称不同不能构成重载，只是方法的重复调用，会导致报错。  



**可变参数**

java允许同一类中多个同名同功能但参数个数不同的方法，将其封装成一个方法。使用可变参数时，可以当做数组使用。

注意事项：(1) 可变参数的实参可以为0个或任意多个。(2) 可变参数的实参可以为数组（本质也是）(3) 可变参数可以和普通类型的参数一起放在形参列表，但可变参数在最后(4) 一个形参列表只能出现一个可变参数

e.g.

```java
public int sum(int... nums){
    int sum = 0;
	for(int i=0;i<nums.length();i++){
        sum += nums[i];
    }
    return sum;
}
```



### 重写

方法重写/覆盖（override），是指**子类**有一个方法和**父类**的名称、返回类型、形参一致。

满足条件：(1) 子类方法的**形参列表、方法名称**与父类的完全一样； (2) 子类方法的**返回值类型**与父类一样，或是父类返回值类型的子类；(3) 子类中重写方法的访问范围应该和父类中一样或更大，不允许子类方法缩小父类的范围

重写override和重载overload要求**方法名**都相同，其**区别**在于：

* 重载发生在本类、重写发生在父类和子类；
* 重载要求**形参列表**的类型、个数和形参属性的顺序至少有一个不同，重写要求**形参列表**完全一样；
* 重载对**返回值类型**无要求，且不能作为重载的条件；重写要求子类重写方法的**返回值类型**和父类中一样或是其子类；
* 重载对**访问修饰符**无要求，且不能作为重载的条件；重写方法要求其子类方法的**访问范围**大于等于父类，即不能缩小父类方法的范围；



---



# 面向对象（基础）

### 基本概念

面向对象（Object Oriented）是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用**对象、类、继承、封装、多态**等基本概念来进行程序设计。从现实世界中客观存在的事物（即对象）出发来构造软件系统，并且在系统构造中尽可能运用人类的自然思维方式。

类是共同特征的描述，对象是真实存在的具体实例。

一个类中包括：**成员变量、成员方法、构造器、代码块、内部类**

创建对象格式：`类名 对象名 = new 类名();`	

**new关键字**

使用关键字new来创建一个对象也叫类的**实例化**，使用new创建对象时，会自动调用构造方法初始化对象。

语法：`类名 对象名 = new 类名(); `

new注意事项：(1) `new 类名()`返回一个对象的地址；	(2)new前后两个类名可以不同，此时前一定是后的父类，这被称为多态（向上转型）；

**this关键字**

jvm给每个对象分配this，用于代表**当前对象**，可以用来区分属性和局部变量。

this注意事项：(1) this可以用来访问本类的属性、方法和构造器，不能在类定义的外部使用，只能在类定义的方法中使用；(2) 在构造器中访问只能在构造器中访问另一个构造器，此时可以实现构造器的复用：`this(prop1,prop2);`；(3) **this只能放在构造器中的第一句**；

**注意事项**

* 类名首字母需要大写，并满足驼峰模式；
* 一个JAVA文件可以定义多个Class类，**但每个文件中只有一个类是public修饰**，且public修饰的类名必须为文件名；在实际开发中一个文件定义一个class类
* 用new创建但没有用对象接收的对象被称为匿名对象，匿名对象在执行完成后会自动销毁；
* 当令一个对象等于另一个对象，则这两个对象实际上指向的是同一个内存空间；



### **对象内存布局和分配**

过程：

1. 创建对象后，会首先在**方法区**加载类的信息；
2. 然后根据类信息在**堆**中分配空间并创建一个对象（每个新对象都会创建一个新的内存空间）；
3. 对象初始化三步骤（1：属性根据类型进行默认初始化；2：根据显式赋值进行初始化；3：检测是否有构造器进行初始化）【如果属性为字符串（引用类型）则属性名指向**方法区的常量池**】
4. 将**堆**中的地址返回给**栈**中的对象引用（在程序中表现为对象名），这个地址会指向该对象（对象中包含对象的属性和方法）。



### 变量

**成员变量（也叫属性、字段）**

属性是类的一个组成部分，一般是基本数据类型,也可以是引用类型。一般无需指定初始化值，变量存在默认值；

定义方法和变量相同：`访问修饰符 数值类型 propertyName;`



**作用域**

变量主要包括局部变量和全局变量。

局部变量：定义在成员方法内部，作用域在定义它的代码块中。必须有初始值。

全局变量（成员变量、属性）：定义在方法外，作用域为整个类体。由于有默认值不一定要赋值。



**注意事项**

* 全局变量和局部变量可以重名，访问时遵循就近原则；

* 在同一个作用域中，两个变量不能重名；

* 局部变量的生命周期短，其随代码块的执行而创建，随代码块的结束而死亡，只存在于一次方法的调用中；全局变量生命周期长，随对象创建而创建，随对象销毁而销毁；

* 全局变量可以加修饰符，局部变量不可以加修饰符；

* 局部变量只能在本类指定方法内使用，全局变量可以被本类和其它类使用。（其它类使用时要创建对象或在形参中传入一个对象）



### **构造器**

构造器又叫构造方法，是类的一种特殊成员方法。主要用于在**创建新对象**时，完成其初始化。构造器**没有返回值和返回类型**，**构造器的方法名和类名需要保持一致**。在对象创建过程中，系统会**自动**调用该类的构造器完成对象的初始化操作。

基本语法：`修饰符 方法名(形参列表){方法体;}`

 e.g. 

```java
//e.g.
public class demo {
    public static void main(String[] args) {
        Person p1 = new Person();
        Person p2 = new Person("tan",12);
        System.out.println(p1.name+' '+p1.age);
        System.out.println(p2.name+' '+p2.age);
    }
}

class Person{
    String name;
    int age;

    Person(){//无参构造器
        age = 10;
    }
    Person(String pName,int pAge){//有参构造器
        name = pName;
        age = pAge;
    }
}
```

**注意事项**

* 一个类可以定义多个不同的构造器（构造器重载）；
* 如果程序中没有定义构造器，则系统会自动为类生成一个默认无参构造器：`类名(){}`；
* 类中一旦自定义了构造器，默认构造器就会被覆盖（此时为了便捷，可以自己定义一个无参构造器用于重载）。



### **访问修饰符**

访问修饰符用于控制**[类、成员变量、成员方法、构造方法]**使用的范围。

**访问修饰符包括public、protected、默认（不写时）、private**，从左到右访问范围逐渐减小；四种访问修饰符的范围如下：
(1) public：公开级别，表示公开访问；
(2) protected：受保护级别,对**子类和同一个包**中的类公开；
(3) 不写：默认级别，只对**同一个包**中的类公开；
(4) private：私有级别，只有类本身可以访问，不对外公开。

**访问范围包括：同类、同包、子类、不同包**，从左到右范围逐渐增大；不同访问范围可以允许的权限如下：
(1) **同一个类下**，允许public、protected、默认、private 的变量或方法进行访问；
(2) **同一个包下**，允许public、protected、默认 的变量或方法进行访问；
(3) **子类下**，允许public、protected 的变量或方法进行访问；
(4) **不同包下**，只允许public 的的变量或方法进行访问。

**注意事项**

* 访问级别只适用于类和类的成员，不适用于局部变量；
* 类只能用默认和public进行修饰；
* 虽然低权限的内容只能限定的范围被访问，但可以通过该范围内的方法取得该内容。**（封装）**



### **Object类**

object类是类层次结构的根类，每个类都使用Object作为超类。所有程序都实现这个类的方法。



**equals()方法**

equals()是Object的方法，只能判断引用类型；在Object的多个数据类型的子类中常被重写。

==和equals()的不同点：当对两个对象进行操作时，==比较两个对象的地址是否相等，equals()可以比较两个对象的值是否相等（默认也是比较地址）



**hashCode()方法**

返回该对象的哈希码值。Object类定义的hashCode方法会针对不同的对象返回不同的整数。

作用：

1、主要用于提高具有哈希结构的容器的效率

2、两个引用，如果指向的是同一个对象，则哈希值肯定是一样的；如果指向的是不同对象，则哈希值一般是不一样的。

3、 哈希值主要根据地址计算， 不能完全将哈希值等价于地址。

 

**toString()方法**

返回该对象的字符串表示，默认的toString()方法返回值与**对象引用的值**一致。默认返回：**全类名(包名+类名)+@+哈希值的十六进制**。子类往往重写toString方法，用于返回对象的属性信息。

重写 toString 方法后，打印对象或拼接对象（对象引用）时，都会自动调用该对象的 toString 形式。

获取全类名（在类中） ：`getClass().getName();`

获取对象的hashCode并转成16进制：`Integer.toHexString(hashCode())`



**getClass()方法**

返回对象的运行类型。



**finalize()方法**

当垃圾回收器确定不存在该对象的更多引用时，由对象的垃圾回收器调用此方法。当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以**重写**该方法，完成**资源释放**。

什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用  finalize 方法。垃圾回收机制的调用，由系统来决定(即有自己的GC算法)，也可以通过`System.gc()`主动触发垃圾回收机制。

实际开发中，不会运用finalize方法，理解即可。



---



# 面向对象（中级）

### **封装**

封装（**encap**sulation）就是把抽象出的数据（属性）和对数据的操作（方法）封装在一起，数据被保护在内部，程序中的其他部分**只能通过被授权的操作**才能对数据进行操作；

封装的作用：(1) 隐藏细节：调用（传入参数）-->方法（连接数据库）；(2) 对数据进行验证，保证安全合理。

实现步骤：

(1) 将属性进行私有化(private)，让外部不能修改属性；

(2) 提供一个公共(public)的set方法，用于对属性判断并赋值；也可以通过构造器的方式对属性进行赋值；

(3) 提供一个公共的get方法，用于获取属性的值；



### **继承**

继承可以**解决代码复用**，让编程更加接近人类思维，当多个类存在同样的属性和方法时可以从这些类中**抽象**出父类/基类，在父类中定义**相同的属性和方法**。

子类/派生类只需要通过**extends**声明继承父类，此后子类会自动拥有父类定义的属性和方法。子类最多只能继承一个父类（指直接继承），因此java是**单继承机制**。

基本语法：`class subClass extends superClass{}`

设计基本思想：继承必须满足**子类is父类**的逻辑，不能滥用继承。（父类的构造器完成父类属性的初始化，子类的构造器完成子类属性的初始化。）

继承的作用：(1) 提高代码的复用性；(2) 提高代码的扩展性和可维护性；



**继承本质**

一个子类对象时，会在方法区加载类信息：先由最顶级父类开始依次加载父类的信息，每个阶层的父类的所有属性（无论是否是重复名称的变量，是否private）都会存入到该对象在堆中的空间；

当创建一个子类对象时，会在方法区加载类信息：先由最顶级父类(Object...)开始依次加载父类的信息，每个阶层的父类的所有属性（无论是否是重复名称的变量，是否private）都会存入到该对象在堆中的空间；

当用**子类对象访问属性(prop/this.prop)**时，遵从以下规则：首先看子类自身是否有该属性，如果有并且可以访问则返回子类的这个属性；如果没有该属性，则看父类是否有该属性，如果有则访问且返回，如果没有则依次向上继续该操作；
当用**super方法**在子类访问父类属性或方法时，**从直接父类往上一级**开始寻找。



**super关键字**

super代表父类的引用，用于访问父类的属性、方法、构造器

语法：

* 访问父类的属性（不能访问private属性）：`super.属性名`；
* 访问父类的方法（不能访问private方法）:`super.方法名(参数列表)`; 
* 访问父类的构造器（只能放在**子类构造器**的**第一句**，且**不能**再使用this(参数列表)）：`super(参数列表)；`
  * 在子类构造器中如果不指定或不写父类的构造器则会自动调用无参构造器：`super();`
  * super方法只能放在构造器的第一行（由于this方法也只能放在第一行，所以两个方法不能共存在一个构造器内）；
  * 如果父类**没有实现无参构造器（只有有参）**，子类必须在构造器的第一行指定使用父类的有参构造器；



**注意事项**

* 子类继承父类所有的属性和方法（包括私有），但父类的私有属性或方法不能在子类中直接访问，可以在父类通过公共的方法间接访问；

* 子类创建相关对象（每创一个）时**自动、必须、最先**调用父类的构造器（从最顶级的父类Object开始，逐步往下调用），也可自定义使用指定的父类构造器完成父类的初始化；  
* java的所有类都是Object类的子类，Object是所有类的基类，因此每次调用类的构造器都会先调用Object的构造器； 
* 当子类和父类有**重名**的属性或方法时，必须使用super访问父类的成员，使用this或直接变量名的方式可访问子类的成员；如果没有重名，则直接访问和super/this效果一致。



### 多态

多态（polymorphic)是指方法或对象有多种形态。多态建立在封装和继承之上。主要解决代码中复用性不高的问题，复用性不高导致代码维护困难。

多态的体现：(1) 方法的多态：重写和重载；(2) 对象的多态：是多态的**核心**，对象多态的前提是两个对象是一对继承关系，具体见下。

对象多态的多种写法：

```java
//(1)向上转型和向下转型
Base a = new Sub();//创建一个父类的对象引用a指向子类对象(向上转型)
Sub a_s = (Sub)a;//将父类的对象引用a强转为子类的对象引用a_s（向下转型）
//((Sub)a).method();//可以调用到子类独有的方法, 常代替上一句（向下转型的简化版）
//(2)形参为父类引用，实参为子类引用时常使用
Sub s = new Sub();//创建一个Sub类型的对象s
Base b = s;//将之前创建的Sub对象的地址赋给b，实际就是将父类引用指向子类对象（向上转型）
//(3)修改对象的运行类型（指向另一个子类）
Base a = new Sub1();//创建一个父类的对象引用a指向子类对象(向上转型)
Sub1.method();//指向Sub1s的method
a = new Sub2();//修改animal的运行类型
Sub2.method();//指向Sub2的method
```



**编译类型和运行类型**

编译类型可以理解为编译器(javac)看到的对象的类型，运行类型可以理解为对象真正执行(java)时的类型。**编译类型在对象定义时=号的左边，运行类型在=号的右边**；

例如`Animal animal = new Dog();`	animal的编译类型时Animal，运行类型是Dog。

判断A的运行类型是否是B或B的子类，返回boolean值：`A instanceof B`



**对象的多态（重要）**

**规则：一个对象的编译类型和运行类型可以不一致；编译类型在定义对象时就已经确定，不可改变，而运行类型可以改变。**

**体现：(1) 父类的引用可以指向子类的对象（向上转型）；(2) 父类引用可以强制转换为子类引用（向下转型）。**



**向上转型**

**本质：**父类引用可以指向子类对象。

**应用场景：**需要用一个方法传入多种子类时，可以使用向上转型。

**语法：**`父类类型 引用名 = new 子类类型();`

**规则：**

* 实现多态向上转型的对象只能调用父类的所有成员（仍需遵守访问权限），而不能调用子类**特有**（子类有父类无）的成员【若要访问需要向下转型】； 

* 在编译阶段，能调用哪些成员是由**编译类型（父类）**决定的，如果一个方法子类有父类无，用父类引用去访问会报错【该条是上一条的原因】；

* 在执行阶段，程序的最终运行效果是由**运行类型（子类）**决定的，即在出现**重写的方法 被调用**时，按照从子类开始向上查找方法。



**向下转型**

**本质：**将父类引用强制转换为子类引用。

**应用场景：**当访问的方法为**子类特有**时，需要将父类引用转换为子类引用再调用。

**语法：**`子类类型 新子类引用名 = (子类类型)父类引用;`

**规则：**

* 只能强转父类的引用，不能强转父类的对象；
* 强转中要求**父类引用**必须指向的是原有目标类型 （向上转型中的子类）的对象；【如果试图将父类引用转换为其他对象，会报ClassCastException错误】
* 当向下转型后，就可以调用子类类型的所有成员（子类也可向上访问到父类）；

e.g. [exercise demo](F:\MyGit\java\basic-app\src\com\hspedu\polymorphic\exercise)

```java
public class demo {
    public static void main(String[] args) {
        Object obj = "hello";//向上转型：将父类引用(obj)指向子类对象（String的"hello")
        String objStr = (String)obj;//向下转型：将父类引用强制转换为子类引用，父类引用指向的String是当前目标类型
        Object objPri = new Integer(5);//向上转型：将父类引用(Object的obj)指向子类对象（Integer的5)
        //String str = (String)objPri;//报错，因为强转过程中父类引用未指向原有的子类对象(Integer)
        Integer str1 = (Integer)objPri;//向下转型：将父类引用(objPri)强制转换为子类引用(str1),父类引用指向的Integer是原有的目标对象
    }
}
```



**java的动态绑定机制（重要）**

当调用对象**方法**的时候，该方法会和该对象的内存地址/**运行类型**绑定；

当调用对象**属性**的时候， 不会触发动态绑定机制，哪里声明就在哪里使用。

e.g. [DynamicBinding demo](F:\MyGit\java\basic-app\src\com\hspedu\polymorphic\DynamicBinding)

```java
public class DynamicBinding {
    public static void main(String[] args) {
        //a 的编译类型 A, 运行类型 B
        A a = new B();//向上转型
        //由于运行类型B中没有sum()，向上寻找后使用父类的sum()；动态绑定机制使得，sum()中的getI()使用运行类型B中的getI()
        System.out.println(a.sum());
        //由于运行类型B中没有sum1()，向上寻找后使用父类的sum1()；属性没有动态绑定，sum()中的i使用就近类型A中的i（在哪用哪）
        System.out.println(a.sum1());
    }
}

class A {//父类
    public int i = 10;
    //动态绑定机制
    public int sum() {//父类sum()
        return getI() + 10;//20 + 10
    }
    public int sum1() {//父类sum1()
        return i + 10;//10 + 10
    }
    public int getI() {//父类getI  
        return i;
    }
}

class B extends A {//子类
    public int i = 20;
    public int getI() {//子类getI()
        return i;
    }
}
```



**多态的应用**

(1) 多态数组：数组的定义类型为父类类型，其中的元素为子类类型

e.g. [Ojbect array demo](F:\MyGit\java\basic-app\src\com\hspedu\polymorphic\array)

```java
public class demo {
    public static void main(String[] args) {
        Person[] persons = new Person[5];//对象数组
        persons[0] = new Person("A", 18);//Person有两个属性：name和age
        persons[1] = new Teacher("B",22,30000);//Teacher继承Person,有特有属性salary
        persons[2] = new Teacher("C",23,20000);
        persons[3] = new Student("D",24,100);//Student继承Person，有特有属性score
        persons[4] = new Student("E",25,97);

        for (int i = 0; i < persons.length; i++) {
            System.out.println(person[i].say()};
    }
}
```

(2) 参数多态：通过将子类对象引用作为实参传入形参为父类引用的方法中(父类引用指向子类对象)，实现不同类型对象的传入。

e.g. [Master feed animals demo](F:\MyGit\java\basic-app\src\com\hspedu\polymorphic\basic)

e.g. [Empolyee getAnnual demo](F:\MyGit\java\basic-app\src\com\hspedu\polymorphic\parameter)

```java
//e.g.应用(3) 
public class PolyTest {
    public static void main(String[] args) {
//        Animal animal = new Dog();//Animal是编译类型 Dog是运行类型
//        animal.cry();//此时运行Dog的cry():运行时，看animal的运行类型决定该行的执行情况
//        animal = new Cat();//修改了animal的运行类型
//        animal.cry();//此时运行Cat的cry()
        Master master = new Master("Tom");
        Cat c = new Cat("喵喵");//Cat继承Animal
        Dog d = new Dog("大黄");//Dog继承Animal
        Beef f1 = new Beef("五花肉");//Beef继承Food
        Pork f2 = new Pork("牛肚");//Pork继承Food
        master.feed(c,f1);//多态的体现：形参为父类引用，实参为子类引用
        master.feed(d,f2);//同上
    }
}
    }
}
```



---



# 面向对象（高级）

### 静态成员（static关键字）

**静态变量**

**静态变量/静态属性**又称为类变量，由**static**修饰。该变量会被**同一个类的所有对象实例共享**，是该类所有对象共享的变量，任何一个该类的对象访问/修改它时，都是对同一个内存地址存放的变量操作。

**定义**语法：`访问修饰符 static 数值类型 staticVar;`	或	`static 访问修饰符 数值类型 staticVar;`

**访问**类对象的语法：`类名.staticVar`	或	`对象名.staticVar`	(前提是 **满足访问修饰符的访问权限和范围**） 

**使用场景**：当需要让每个类共享一个变量时，考虑使用类变量。

生命周期：类变量的生命周期由类的加载开始，随类的消亡而销毁；

**类变量注意事项：**

* 类变量是在**类加载**的时候生成和初始化的，即使没有创建对象实例也可以访问；
* 静态变量可以被修改，一旦被修改则所有该类的对象的属性都会被修改；
* 类变量是该类的所有对象共享的，而实例变量（普通属性/非静态变量）是每个对象独享的；
* 非静态变量可以接收静态和非静态变量类型返回值方法，而静态变量只能接收静态变量类型返回值方法；



**静态方法**

类方法就是用static修饰的方法。java中的方法可以分为**静态方法**和**非静态方法**。静态方法和静态数据成员会随着**类加载**而被分配和装载入内存中，非静态成员只有在**类的对象创建时**在对象的内存中才有这个成员的代码段。

定义语法：`访问修饰符 static 数值类型 staticMethod(){}`	或	`static 访问修饰符 数值类型 staticMethod(){}`

访问类方法的语法：`类名.staticMethod()`	或	`对象名.staticMethod()`	(前提是 **满足访问修饰符的访问权限和范围**） 

**使用场景**：当方法中不涉及任何和对象相关的成员，则可以将方法设计为静态方法，可以不用创建新对象，提高开发效率。



**发生类加载的时刻（☆）：**(1) 使用new创建对象实例时；(2) 创建子类实例对象时，父类会被加载；(3) **使用类的静态成员时（属性或方法）**



**类方法注意事项:**

* 类方法的**结构信息**和普通方法一样都存放在**方法区**；
* 一般Java中工具类里面的工具方法都用static修饰，作为静态方法；
* 静态方法原则上不允许被重写，因此也不允许被定义为抽象方法； 
* 静态方法中不允许使用this和super等关键字，而非静态方法中隐藏且可以使用这些关键字；
* 构造器属于非静态方法，都可以访问；访问类方法时不会调用构造器，因为没有产生对象；
* **非静态方法既可以**访问静态数据属性/方法**又**可以访问非静态数据属性/方法，而**静态方法只能**访问静态数据属性/方法。



**main方法**

main方法形式：`public static void main(String[] args){}`

解读：(1) main方法由**java虚拟机(jvm)**调用；(2) 必须要求**访问权限**为public以供jvm调用；(3) jvm在执行main()方法时不创建新对象，因此是static修饰的**静态方法**。main方法接收String类型的数组参数在args数组中保存执行java命令时传递给所运行类的参数。

注意事项：
**在main()方法下**，可以直接调用**main方法所在类**的**静态成员**，但不能访问该类的非静态成员（要通过创建实例对象，通过对象访问非静态成员）



### 代码块

代码化块又称为**初始化块**，属于类中的成员。可以分为**静态代码块**和**普通代码块**，都可以看做**另一种形式的构造器**（对构造器的补充机制），可以做初始化操作；

与方法不同的是，代码块没有方法名，没有返回值，没有参数，只有方法体，而且不用通过对象或类显式调用。其在**加载**类或**创建**类时**隐式调用**。

**语法**：`[修饰符] {代码};`	修饰符可选(static)，代码最后的;可加可不加。

**使用场景**：如果多个构造器中有重复的语句，可以抽取到初始化块中，提高代码的重用性；

**静态和普通代码块的区别：**
静态代码块是随着**类的加载**进行的，**只会执行一次**； 
而普通代码块是在**创建一个对象时**执行的，实际先执行的是对象的构造器部分，只是构造器的**最前面**隐含着**super()和普通代码块的调用**，因此每创建一个该类对象就执行一次（与类加载无关，所以只使用静态成员普通代码块不会被调用）

子类构造器的隐藏执行：

```java
public A(){
	//(1)调用super();
	//(2)调用普通代码块和普通属性初始化
	初始化代码...
}
```

**创建对象，在一个类中的调用顺序（☆）**：(1) 调用静态代码块和静态属性初始化（两者优先级一致，按定义顺序调用） (2) 调用普通代码块和普通属性初始化（两者优先级一致，按定义顺序调用） (3) 调用构造方法的显式部分（因为代码块和super()隐藏存在于构造器中，因此是构造器显式部分）

产生继承关系时创建子类对象的调用顺序：
(1) 父类静态代码块和静态属性；（两者优先级一致，按定义顺序调用）
(2) 子类静态代码块和静态属性；（两者优先级一致，按定义顺序调用）
(3) 父类普通代码块和普通属性初始化；（两者优先级一致，按定义顺序调用）
(4) 父类构造器；
(5) 子类普通代码块和普通属性初始化；（两者优先级一致，按定义顺序调用）
(6) 子类构造器；



**基本原则：**

* 静态代码块只能调用静态成员，普通代码块可以调用任意成员；



**注意事项：**

* 调用子类的静态成员时，一定会先加载父类（发生代码块的调用）；
* 代码同时含有静态代码块和普通代码块会一起被调用（无论定义先后，都是静态代码块先被调用）；
* 父类的static方法不可以被子类重写；





### **final关键字**

final可以修饰**类、属性、方法和局部变量**。由final修饰的属性一般称为**常量**。包装类（Integer,Double,String）都是final类。

**使用场景**：

(1) 不希望**类被继承**时，可以用final修饰类；

(2) 不希望父类的某个方法被子类**重写或覆盖**(override)时，可以用final关键字修饰；

(3) 不希望类的某个**属性的值被修改**，可以用final修饰；

(4) 不希望某个**局部变量被修改**，可以用final修饰；



**final变量的初始化**

final修饰的属性必须**在定义时赋予初值**，并且以后**不能修改**； 

final修饰的一般属性的赋值位置可以在**类定义中**、在**构造器中**或在**普通代码块**中（建议在定义时赋值）；如果final修饰的属性是**静态属性**，则初始化的位置只能在**定义中**或**静态代码块**中（不能在构造器，因为静态属性在类加载时就要进行初始化，构造器是在对象创建时调用的）；



**基本原则：**

* final类不能被继承，但可以实例化对象；
* 非final类里如果有final方法，虽然该方法不能被重写，但是可以被继承；
* 如果一个类已经是final类，则没有必要再将方法修饰为final方法；
* 当我们用final修饰一个引用类型的数据（数组等），表示不允许修改变量存放的地址（不能再指向新的对象）。



**注意事项：**

* final不能修饰构造方法；
* 如果有属性是final修饰，则不能存在无参构造器；
* final和static往往搭配使用（前后均可），效率更高（底层编译器有相关优化）：当在主方法中调用final修饰的静态变量不会发生类加载。



### 抽象类

当父类的某些方法需要声明，但又不确定如何实现时，可以将其声明为抽象方法，此时该类就是抽象类；所谓抽象方法就是没有实现的方法（没有方法体）。一般来说，抽象类会被继承，由其子类通过重写实现抽象方法。

用abstract关键字修饰该方法则方法称为抽象方法，用abstact修饰类就称为抽象类。

语法：`访问修饰符 abstract 数值类型 方法名(参数列表);`（不能有方法体）	此时类也需要改为：`abstract class 类名{}`


**基本原则：**

* 抽象类**不能被实例化**；

* abstract只能修饰类和方法，不能修饰属性和其它内容；
* 当一个类中存在抽象方法时，必须将该类声明为abtract类；而抽象类不一定要包含abstract方法；
* 抽象方法不能有方法体（大括号）；而如果一个类继承了抽象类，则它必须实现（拥有方法体）抽象类的**所有抽象方法**，除非自身也是抽象类；



**注意事项:**

* 抽象类本质还是类，可以有正常类的相关成员（非抽象方法、构造器、静态方法等）；
* 抽象方法不能使用**private**、**final**和**static**修饰，因为这些关键字都和重写违背。  





### 接口

java中有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。接口可以实现**多重继承**的效果。

接口主要用于给出一些没有实现的方法，将他们封装到一起。当某个类要使用时根据具体情况实现该接口。从本质上讲，接口是一种特殊的**抽象类**，这种抽象类中**只包含常量和方法的定义**，而没有变量和方法的实现。

接口中的**所有成员变量**都默认是由`public static final`修饰的，可以省略public static、final关键字；接口中的所有方法都默认是由`public abstract`修饰的，可以省略public和abstract关键字；

接口语法：

```java
interface 接口名{
	//属性
	//方法
}
```

实现接口的类语法：

````java
class 类名 implements 接口名{
    //类专有属性
    //类专有方法
    //必须实现的接口中所有抽象方法
}
````

**默认方法**语法（默认方法是一种特殊的方法，主要用于接口中的实现方法）：`访问修饰符 default 数值类型 方法名(){...}`	访问修饰符可以省略，此时默认为public；default也可以放在访问修饰符前。

访问**接口中**的属性（类似于类变量，类的实现可以让类继承接口中的属性）：`接口名.属性名` 或 `实现类名.属性名`或`实现类对象.属性名`



多继承语法：

```java
class 类名 implements 接口1,接口2{
	//类专用属性和方法
    //必须实现的接口1的抽象方法
    //必须实现的接口2的抽象方法
}
```



**基本原则：**

* 接口没有构造方法，因此**不能被实例化**；只能通过**实现(implements)接口的类**进行实例化；
* **普通类**实现接口，必须实现接口中的所有方法；**抽象类**实现接口，可以不实现接口的方法；
* 接口不能继承类，但可以**继承**多个其他接口：`interface A extends B,C{...}`，注意是extends而不是implements；



**注意事项：**

* jdk7前，接口中的所有方法没有方法体，而在jdk8开始接口中可以有**静态方法和默认方法**（默认方法用default修饰）；
* 
* 接口的访问修饰符只能是public或默认，与类的访问修饰符一致；
* 如果父类和其接口有重名的对象，要注意作区分：访问父类用`super.x`，访问接口用`接口名.x`，否则会报错；



**接口和继承的比较**

**解决问题**不同：

继承：当子类继承了父类，就自动拥有了父类的功能；主要价值在于解决代码的复用性和可维护性；

接口：如果子类需要扩展功能，可以通过实现接口的方式扩展。**接口的实现实际是为java单继承机制的补充。**接口的价值在于设计好各种规范，使得可以更好地利用。

**逻辑关系**不同：逻辑上接口是like a的关系，继承是is a的关系。

**灵活程度**不同：接口比继承更灵活。接口在一定程度上可以实现代码解耦的功能（接口的规范性+动态绑定）；

**规范和规则**不同：实现接口的类必须实现接口中所有的方法，而继承中的方法只会出现重写（此时会发生动态绑定）



**接口的多态**

接口引用可以指向实现该接口类的对象（向上转型）；当发生接口的多态时，会执行该接口实现类的方法 （动态绑定）

e.g.

```java
public class ComputerDemo {
    public void work(Usb usb){
        usb.start();
        usb.stop();
    }

    public static void main(String[] args) {
        ComputerDemo c = new ComputerDemo();
        ////这里发生了多态：形参是接口的引用，实参是实现该接口的对象（可以接受手机的对象也可以接受相机的对象）
        //还发生了动态绑定，实参对应对象的运行类型，因此调用的work绑定Camera的work
        c.work(new Camera());
        c.work(new Phone());
    }
}

interface Usb {
    void start();
    void stop();
}

class Camera implements Usb{
    //实现Usb中的抽象方法...
}

class Phone implements Usb{
    //实现Usb中的抽象方法...
}
```

**接口多态的传递**

e.g.

```java
public class InterfacePolyPass {
    public static void main(String[] args) {
        IG ig = new Teacher();//接口的引用可以指向 实现了该接口类的对象实例
        IH ih = new Teacher();//由于Teacher也实现了IH的接口，因此也可以实现向上转型
    }
}

interface IH{
}

interface IG extends IH{//此时实现IG的类也需要实现IH
}

class Teacher implements IG{
}
```



### 内部类

内部类是指一个类的内部又完整的嵌套了另一个类的结构。被嵌套的类被称为内部类。

内部类的最大特点是：可以**直接访问**外部类的私有属性，可以体现类与类之间的包含关系。

语法：

```java
class Outer{//外部类
	class Inner{//内部类
	//...
    }
}

class Others{//外部其它类
}
```



**内部类的划分**

(1) 当内部类定义在外部类局部位置上（比如方法内）：局部内部类（分为有方法名和无方法名，无方法名被称为**匿名内部类**）

(2) 当内部类定义在外部类的成员位置上：非静态成员内部类（没有static修饰）、静态成员内部类（有static修饰）



#### **局部内部类**

局部内部类，是定义在外部类局部位置上，比如方法中（称为方法内部类），并且有类名。

作用域：局部内部类的作用域仅仅在**定义**它的方法或代码块中。



**访问规则：**

* (首先需要满足访问修饰符条件)

* **局部内部类**访问**外部类**的成员：直接访问其全部成员，包括私有成员；

* **外部类**访问**局部内部类**的成员：在定义该内部类的方法或代码块中（作用域）创建内部类的对象，然后再调用方法即可；

* **外部其它类不能**访问**局部内部类**（因为局部内部类属于局部成员，只能在指定的作用域中访问）



**基本原则：**

* 不能给局部内部类添加访问修饰符，但可以用final修饰该类；
* 外部类和局部内部类的成员重名时，默认就近原则；在内部类中访问外部类的成员（如果没有重名可以直接访问）：`外部类名.this.成员`（此处，`外部类名.this`本质就是外部类的对象）；



**实践：**

```java
public class demo1 {
    public static void main(String[] args) {
        Outer01 outer01 = new Outer01();
        outer01.m1();
    }
}

class Outer01{
    private int n1 = 100;
    private void n2(){
        System.out.println("outer01 m2()被调用");
    }

    public void m1(){
        final class Inner01{//局部内部类
            public void f1(){
                System.out.println("显示n1="+n1);//可以访问私有成员
                n2();//可以访问私有成员
            }
        }
        Inner01 inner01 = new Inner01();//访问局部内部类的成员（先创建对象，再调用方法）
        inner01.f1();
    }
}
```





#### **匿名内部类（☆）**

匿名内部类定义在外部类的局部位置，通常在方法中，**没有类名**。

匿名内部类在语法上看既有**定义类**的特征，也有**创建对象**的特征。

**使用场景**：某个内部类只想使用一次，后面不再使用 -> 使用匿名内部类简化开发。

作用域和访问规则：同局部内部类。



语法（用对象接收/传入方法）：`接口名/类名 对象 = new 接口名/类名(){...};`(分号不能省)

语法（直接调用接口或类中的方法）：`new 接口名/类名(){...}.method(参数列表); `	（method在方法体{}中）



**基本原则：**

* 当我们基于**接口名**创建匿名内部类时，编译器底层会自动分配类名：**外部类名$x**，x为匿名内部类的个数（从1开始）；

    如果创建了对象，则对象的编译类型为该接口，运行类型为自动分配的类，具体实现为方法体中的内容。

    显式表达为：`new 接口名(){...};`	->	`new 外部类名$x implements 接口名{...}`

* 当我们基于**类名**创建匿名内部类时，编译器底层会自动分配类名：**外部类名$x**，x为匿名内部类的个数（从1开始）；

    注意该类可以为非抽象类也可以为抽象类，视具体问题而定，如果该类为抽象类则内部类必须实现抽象类的所有方法。
    
    如果创建了对象，则对象的编译类型为该类，运行类型为自动分配的类，具体实现为方法体中的内容。程序会首先运行编译类型的构造器。
    
    显式表达为：`new 类名(参数列表){...};`	->	`new 外部类名$x extends 类名{...}`

**实践：**

匿名内部类可以提高代码的**灵活性**，防止出现硬编码的牵一发而动全身的情况。

e.g.:匿名内部类可以作为实参直接传递(涉及到的知识点：继承、多态、动态绑定、内部类)

```java
public class AnnoymousInnerClassdemo {
    public static void main(String[] args) {
        test(new Test(){//直接将new Test(){}作为实参传给test方法
            @Override
            public void show() {
                System.out.println("显示内容");
            }
        });//匿名内部类，临时创建类有利于代码维护
    }

    public static void test(Test t){
        t.show();
    }
}

interface Test{
    void show();
}
```



#### **非静态成员内部类**

非静态成员内部类定义在外部类的成员位置，没有static修饰。

**作用域：** 整个类体

**注意点：** 可以为成员内部类添加任意的访问修饰符，因为成员内部类本质上就是一个成员；

**访问规则：**

* (首先需要满足访问修饰符条件)

* **成员内部类**可以直接访问**外部类**的所有成员，包括私有的；

* **外部类**访问**成员内部类**的成员：在外部类中定义一个方法，创建该内部类的对象，再访问；

* **外部其它类**访问**成员内部类**的成员：两种方式

  [1] `Outer.Inner inner = outer.new Inner();`	用inner对象访问Inner的成员；

  [2]在外部类中，定义一个方法:`public Inner getInstance(){return new Inner();}`在其他外部类中：`Outer.Inner inner=outer.getInstance();`

* 外部类和内部类的成员重名时，用内部类访问时遵守就近原则优先访问内部的成员。如需要访问外部成员使用：`外部类名.this.成员名`



#### **静态成员内部类**

静态成员内部类定义在外部类的成员位置上，有static修饰。

**作用域：**整个类体

**注意点：**可以为成员内部类添加任意的访问修饰符，因为成员内部类本质上就是一个成员；

**访问规则：**

* **静态内部类**可以直接访问**外部类**的所有静态成员，不能访问非静态成员；
* **外部类**访问**静态内部类**：需要定义一个方法然后在方法中创建对象，再访问；
* **外部其他类**访问**静态内部类**：[1]`Outer.Inner inner = outer.new Inner();`[2]定义（静态的）返回Inner对象的方法，在外部类`Outer.Inner inner = Outer.getInstance();`（如果为静态方法，可以直接用类名访问）；
* 外部类和内部类的成员重名时，用内部类访问时遵守就近原则优先访问内部的成员。如需要访问外部成员使用：`外部类名.成员名`



---

# 其他操作

### 枚举

枚举（enumeration）写作enum，是一组**常量**的集合。



**自定义类实现枚举**

特点：构造器私有化；本类内部创建一组对象（对外暴露：`public static final`修饰）；提供get方法但不提供set方法。

**使用细节：**

* 不需要提供setXxx方法，因为枚举的对象为可读；

* 对枚举对象/属性使用final+static共同修饰，实现底层优化（在使用枚举对象时不加载类）；

* 枚举对象名通常使用全部大写，这是常量的**命名规范**；

* 枚举对象根据需要，可以有多个属性；

**举例：**

```java
class Season{
    private final String name;
    public static final Season SPRING = new Season("春天");
    public static final Season SUMMER = new Season("夏天");

    private Season(String name){
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
```



**enum关键字实现枚举类**

特点：用enum代替class；构造器私有化；在枚举类的最前面定义常量对象【对象自动添加public static final修饰】（简便方法）；提供get方法但不提供set方法。

在enum修饰的枚举类中可以用：`常量名(参数列表);	`	代替	`public static final 类名 常量名 = new 类名(参数列表);`

枚举对象的传递：`类名 对象名 = 类名.枚举对象名;`

**使用细节：**

* 使用关键字enum替代class（enum和class、interface的地位相同）；
* 枚举对象必须放在枚举类的行首，且只能有一句（用逗号隔开各个常量对象）；

* 如果有多个常量（对象），使用逗号间隔开：`常量名1(...),常量名2(...),...;`

* 如果使用enum实现枚举，要求将常量对象的定义写在**最前面**，否则报错；
* 如果构造器使用**无参构造器**，则创建常量对象可以省略小括号：`常量名1，常量名2,...;`

**注意事项：**

* 枚举类的构造器（有参/无参）只能是私有的，枚举对象会根据参数列表自动选择使用的构造器；
* 当我们使用enum关键字开发枚举类时，默认会继承Enum类(java.lang.Enum)；
* 如果没有重写toString方法，则enum类会继承Enum类的toString。打印对象时会输出对象名；
* 枚举类默认被final修饰，不能继承任何类，这是因为枚举类隐式继承了Enum，java为单继承；枚举类可以实现接口；

**举例：**

```java
enum Season1{
    SPRING("春天"),SUMMER("夏天");//枚举对象必须放在枚举类的行首
    private final String pname;

        private Season1(String name){
        this.pname = name;
    }

    public String getName() {
        return pname;
    }
}
```





**Enum类的内置成员方法**

`枚举对象.name()`	返回枚举对象的名称（不是属性的名称）；

`枚举对象.ordinal()`	返回枚举对象的顺序编号（从0开始）；

`枚举类名[] 数组名 = 枚举类名.values();`	返回定义的**所有**枚举对象（用一个对象数组接收）；

`枚举类名 枚举对象 = 枚举类名.valueOf("字符串");`	将字符串转换成枚举对象，要求字符串必须为已有的常量名（会在枚举类中寻找同名的枚举对象）；

`枚举对象1.compareTo(枚举对象2)`	返回枚举对象是否相等（实际就是用ordinal()方法计算枚举对象的顺序编号之差）；

  

**枚举类实现接口**

枚举类可以实现一个或多个接口。与普通类一样，实现接口的时候需要实现接口中定义的所有方法，若没有完全实现，那这个枚举类就是抽象的，只是不需显式加上abstract修饰，编译器会默认加上。



### **注解**

**介绍：**注解英文名为Annotation，又被称为**元数据**(Metadata)，用于修饰解释 包/类/方法/属性/构造器/局部变量等。和注释一样，注解不影响程序的逻辑，但注解可以被编译和运行，其相当于嵌入到代码中的补充信息。

**使用方法：**使用Annotation时要在其前面加@符号，  并把该Annotation当做一个修饰符使用，用于修饰它支持的程序元素。

**举例：**

(1) `Override`：限定某个方法是重写父类方法，该注解只能用于方法；

(2) `Deprecated`：表示某个程序元素（类、方法）已过时；

(3) `SuppressWarnings`：抑制编译器警告；

**元注解：**用于修饰其他Annotation，包括：(1) Retention（指定注解的作用范围SOURCE CLASS RUNTIME）；(2) Target（指定注解可以在哪些地方使用）；(3) Documented（指定该注解是否会在javadoc中体现）；(4) Inherit（子类会继承父类的注解）



**Override**

@Override表示指定重写父类的方法（从编译层面验证），**只能修饰方法**，不能修饰类、包、属性等。
即使不写该注解依然可以构成重写；但只要写了Override注解，则编译器检查该方法是否为重写方法，如果没有构成重写则会编译错误；



**Deprecated**

@Deprecate用于表示某个程序元素已过时。可以用于修饰方法、类、字段、包、参数等。

被该注解修饰的元素在程序中表示不推荐使用，但是可以使用。用于新旧版本的过渡、兼容使用。

当我们调用Deprecated修饰的元素时，会显示横线。



**SuppressWarnings**

当我们不希望看到警告信息时，可以使用SuppressWarnings注解来抑制警告信息。可以用于修饰具体的语句，方法，类等。

语法：`@SuppressWarnings({"infotype1","infotype2",...})`	不需要分号，注意括号里存放了一个String[]类型的数组。

作用范围：与放置的位置有关

infotype：

| **关键字**               | **用途**                                                     |
| ------------------------ | ------------------------------------------------------------ |
| all                      | to suppress all warnings （抑制所有警告）                    |
| boxing                   | to suppress warnings relative to boxing/unboxing operations （抑制装箱、拆箱操作时候的警告） |
| cast                     | to suppress warnings relative to cast operations （抑制映射相关的警告） |
| dep-ann                  | to suppress warnings relative to deprecated annotation （抑制启用注释的警告） |
| deprecation              | to suppress warnings relative to deprecation （抑制过期方法警告） |
| fallthrough              | to suppress warnings relative to missing breaks in switch statements （抑制确在switch中缺失breaks的警告） |
| finally                  | to suppress warnings relative to finally block that don’t return （抑制finally模块没有返回的警告） |
| hiding                   | to suppress warnings relative to locals that hide variable（抑制相对于隐藏变量的局部变量的警告） |
| incomplete-switch        | to suppress warnings relative to missing entries in a switch statement (enum case)（忽略没有完整的switch语句） |
| nls                      | to suppress warnings relative to non-nls string literals（ 忽略非nls格式的字符） |
| null                     | to suppress warnings relative to null analysis（ 忽略对null的操作） |
| rawtypes                 | to suppress warnings relative to un-specific types when using generics on class params（ 使用generics时忽略没有指定相应的类型） |
| restriction              | to suppress warnings relative to usage of discouraged or forbidden references（ 抑制禁止使用劝阻或禁止引用的警告） |
| serial                   | to suppress warnings relative to missing serialVersionUID field for a serializable class（ 忽略在serializable类中没有声明serialVersionUID变量） |
| static-access            | to suppress warnings relative to incorrect static access（ 抑制不正确的静态访问方式警告） |
| synthetic-access         | to suppress warnings relative to unoptimized access from inner classes（ 抑制子类没有按最优方法访问内部类的警告） |
| unchecked                | to suppress warnings relative to unchecked operations（ 抑制没有进行类型检查操作的警告） |
| unqualified-field-access | to suppress warnings relative to field access unqualified（ 抑制没有权限访问的域的警告） |
| unused                   | to suppress warnings relative to unused code（ 抑制没被使用过的代码的警告） |



### 异常

程序执行中发生的不正常称作"异常"。（语法和逻辑错误不是异常）

执行过程中发生的异常事件可以分为：

1）Error：Java虚拟机无法解决的问题，会导致程序崩溃。（如JVM系统内部错误、资源耗尽【数组越界、栈溢出、OOM等】）

2）Exception：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。（如空指针访问、读取不存在的文件、网络中断等）

Exception可以分为两大类：

(1) **运行时异常**：程序运行时发生的异常(RuntimeException)，即使不进行异常处理(try-catch/throws)也能编译通过（由编译器默认处理）。一般是指编译时的逻辑错误（程序员应该避免，但出现了可以不处理，全处理可能导致效率和可读性的减弱）。是字节码文件在内存加载、运行时发生的；

(2) **编译时异常**：编译器检查出的异常，编译器必须要求处理的异常。此时Java源文件还未编译成字节码文件。



**异常体系图**

<img src="C:\Users\TRT\AppData\Roaming\Typora\typora-user-images\image-20220113104056740.png" alt="image-20220113104056740" style="zoom: 50%;" />



**常用运行异常**(Throwable<-Exception<-RuntimeException)

(1) NullPointerException 空指针异常：当应用程序试图在需要对象的地方使用null时，抛出该异常；

(2) ArithmeticException 数学运算异常：当出现异常的运算条件时，抛出此异常；

(3) ArrayIndexOutOfBoundsException  数组下标越界异常：用非法索引访问数组时抛出的异常；

(4) ClassCastException 类型转换异常：当试图将对象强制转换为不是实例的子类时，抛出该异常；

(5) NumberFormatException 数字格式不正确异常：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常



**常用编译异常**

(1) SQLException：操作数据库时，查询表可能发生异常；

(2) IOException：操作文件时，发生的异常

(3) FileNotFoundException：操作不存在文件，发生的异常；



**异常处理**

 异常处理（又称为错误处理）功能提供了处理程序运行时出现的任何意外或异常情况的方法。异常处理分离了接收和处理错误代码。这个功能理清了编程者的思绪，也帮助代码增强了可读性，方便了维护者的阅读和理解。

方式：(1) try-catch-finally：程序员在代码中捕获发生的异常，自行处理；(2) throws：将发生的异常抛出，交给**上一级调用者**处理（如顶级处理者JVM，会输出异常信息后退出程序）(3) try-finally：不捕获异常，程序遇到异常会崩溃并退出，表示不管是否发生异常都执行某个业务逻辑；



**try-catch-finally**

语法：

```java
try{
//异常代码
}catch(NullPointerException e){//子类异常
    //异常发生时，系统将异常封装成Exception e对象，将该对象传递给catch
    //得到异常对象e后，程序员自己处理
}catch(Exception e){//父类异常
	//其他异常
}finally{//可以省略
    //不管try代码块是否有异常发生时，始终执行finally代码块
}
```

try中放可能发生异常的代码，catch代码块用于写程序员对异常的处理（**如果没有发生异常，catch代码块不执行**），finally表示始终执行的代码块（通常将释放资源、关闭连接的操作放在finally中，可以省略finally） 



**注意事项:**

* **一旦try中的异常发生，异常后面的代码就不会执行**（不管有几个catch)，直接进入catch块；
* 如果异常没有发生，则顺序执行try代码块，不会进入到catch块；
* 可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求父类异常在后(Exception)，子类异常在前(NullPointerException)，如果发生异常只会匹配一个异常）;
* finally代码中一般不包含返回值，但如果程序在catch和finally都存在返回值，则出现异常时会先走catch的返回语句（但不返回，会将该值以临时变量的形式保存起来）再走finally的返回语句；



实践（反复输入直到满足要求）e.g.

```java
Scanner scanner = new Scanner(System.in);
String inputStr = "";
int num = 0;
while(true){
    inputStr = scanner.next();
    try{
        num = Integer.parseInt(inputStr);
        break;
    }catch(NumberFormatException e){
        System.out.print("你输入的不是一个整数：");
    }
}
System.out.println("输入的值为="+num);
```





**throws关键字**

Java总允许在方法的后面使用throws关键字对外声明该方法有可能发生异常，这样调用者在调用方法时，就明确地知道该方法有异常，并且必须在程序中对异常进行处理，否则编译无法通过。

**使用场景：** 如果一个方法（中的语句执行时）可能生成某种异常，但不能确定如何处理，则throws方法应显式地抛出异常，表示该方法不对这些异常进行处理，而由该方法的调用者（上一级）负责处理。

**使用细节：**

* throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类

* throws后可以放多个异常；
* 子类**重写**父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型和父类一致或是父类抛出异常类型的子类型；
* 如果调用者调用了抛出**编译异常**的方法，则调用者也需要用throws抛出该异常（或其父类）或用try catch处理异常，否则报错； 如果调用抛出**运行异常**的方法，则不需要程序员显式的处理，可以由编译器默认处理。
* 运行时异常程序如果没有处理，则会默认使用throws处理；



**throw关键字**

用于**主动**生成异常对象的关键字，位置在**方法体中**。

语法：`throw exceptionObject;`	抛出xxx异常的对象。

对比throws：throws位置在方法声明处，后面跟异常的类型。



**自定义异常**

在程序中，可能会遇到JDK提供的任何标准异常类都无法充分描述清楚我们想要表达的问题，这种情况下可以创建自己的异常类，即自定义异常类。

主要通过继承Exception(编译异常)或RuntimeException(运行异常)实现。



e.g.

```java
public class TestMyException {
    public static void main(String[] args) {
        Person p = new Person();
        try {
            p.setAge(-1);
        } catch (IllegalAgeException e) {
            e.printStackTrace();
            System.exit(-1);
        }
        System.out.println(p);
    }
}

class IllegalAgeException extends Exception {
    //默认构造器
    public IllegalAgeException() {
    }
    //带有详细信息的构造器，信息存储在message中
    public IllegalAgeException(String message) {
        super(message);
    }
}

class Person {
    private int age;

    public void setAge(int age) throws IllegalAgeException {
        if (age < 0) {
            throw new IllegalAgeException("人的年龄不应该为负数");
        }
        this.age = age;
    }
 
    public String toString() {
        return "age is " + age;
    }
}
```



# 常用类

### 包装类

针对八种基本数据类型相应的引用类型被称为包装类(Wrapper)，通过包装类可以使用类中的工具和方法。

Number的子类：**Byte、Short、Integer、Long、Float、Double**	(继承Number类，实现Comparable接口；Number类实现了Serializable接口)

非Number子类：**Character、Boolean**	(继承Object类，实现Comparable和Serializable接口)



**装箱和拆箱（基本数据类型和包装类的转换）**

jdk5.0前需要手动装箱拆箱。

手动装箱：`Integer integer = new Integer(n1);`或`Integer integer1 = Integer.valueOf(n1);`

手动拆箱：`int n = integer.intValue();`

jdk5.0后可以实现自动装箱拆箱。

自动装箱：`Integer integer = n2;`	在底层自动使用`Integer integer = Integer.valueOf(n2);`

自动拆箱：`int n3 = integer;`	在底层自动使用`int n3 = integer.intValue();`

e.g.

```java
Object obj = true?new Integer(1):new Double(2.0);
System.out.println(obj);//由于三元运算符（一个整体）有Double类型的数据，因此1会自动进行类型转换变为1.0
```



**包装类转换为String**

转换目标：`Integer i = 100;`

方式一：`String str = i + "";`

方式二：`String str = i.toString();`

方式三：`String str = String.valueOf(i);`



**String转换为包装类**

转换目标：`String str = "123";`

转换为Integer：`Integer i = Integer.parseInt(str);`（发生了自动装箱 Integer.parseInt()返回一个int数据）



**Integer的==比较**

比较原则：

    (1) 如果比较方有基本数据类型，则只比较数据值是否相等；
    
    (2) 如果比较方都是Integer类型，且有任意一方创建新对象，则地址不同，返回false；
    
    (3) 如果比较方都为Integer类型，没有一方创建新对象，则看数据范围是否都在-127-128之间，是则根据值返回（比较值），不是则一定返回false（创建新对象）。

在java底层代码中，valueOf()方法将int变量装箱。如果int变量的范围在-127-128内，则直接返回值；如果在范围外，则创建一个新对象。

```java
Integer i = new Integer(1);
Integer j = new Integer(1);
System.out.println(i == j);  //False
/*
1. 如果i 在 IntegerCache.low(-128)~IntegerCache.high(127),就直接从缓存数组返回
2. 如果不在 -128~127,就创建新对象 new Integer(i)
public static Integer valueOf(int i) {//底层源码
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}*/
Integer m = 1; //底层 Integer.valueOf(1); -> 阅读源码
Integer n = 1;//底层 Integer.valueOf(1);
System.out.println(m == n); //True
Integer x = 128;//底层Integer.valueOf(1);
Integer y = 128;//底层Integer.valueOf(1);
System.out.println(x == y);//False
Integer k = 128;
int t = 128;
System.out.println(k==t);//True  只要有基本数据类型，则此时比较的就是值是否相等
```



### String类

String对象用于保存字符串，也就是一组字符序列（char数组）。String常量对象就是用双引号括起的字符系列。字符串的字符采用Unicode字符编码，一个字符（不论字母还是汉字）占两个字节。

**常用构造方法：**`String s1=new String();` `String s2=new String(String str);` `String s3=new String(char[] a);`等（String类有十几个可供重载的构造器）

**继承实现关系：**String类**继承**Object类，**实现**Serializable、Comparable、CharSequence接口。Serializable接口保证该类可以串行化，可以在网络传输；Comparable保证类的对象可以相互比较；CharSequence保证该对象是字符序列。

 **注意事项：**

* String属于final类，不能被其他类继承；
* String存放字符串内容的变量为`private final char value[];` String本质上是char类型的数组，final表示这个数组不能被修改（不能指向新的地址空间，而内部的元素允许被修改）；
* 一旦字符串被重新赋值，则会指向一块新的地址，但原先被分配地址的内容不会被修改；



**String对象的创建和内存布局**

方式一：`String s = "abc";`	

方式一先从常量池查看是否有"abc"数据空间，如果有则main栈的变量直接指向该常量的地址，如果没有则重新创建再指向；s最终指向**常量池**的空间地址。

方式二：`String s1 = new String("abc");` （两种方式有本质区别）

方式二先从堆中创建空间，里面维护**value属性值**，属性指向常量池的"abc"空间，如果常量池没有"abc"重新创建再指向；s最终指向**堆**中的空间地址。



**String的比较**

 `.intern()`方法用于返回该字符串常量池的地址。

```java
String a = "hsp"; //a 指向 常量池的 “hsp”
String b =new String("hsp");//b 指向堆中对象
System.out.println(a.equals(b)); //T
System.out.println(a==b); //F
System.out.println(a==b.intern()); //T
System.out.println(b==b.intern()); //F
```



**字符串的特性**

(1) 拼接

```java
String a = "hello";//创建对象a
String b = "abc";//创建对象b
String c = a + b;//在底层先创建一个StringBuilder对象sb，执行两次sb.append()，再String c = sb.toString()【这里在堆中new了一块内存】
System.out.println(c=="helloabc");//false
```

规则：执行字符串**变量**的加法，最后返回的值是在堆中创建的 ；执行字符串**常量**的相加，最后返回的结果是在常量池中创建。

具体细节：jvm首先通过new申请了一个StringBuilder，然后调用这个StringBuilder的初始化方法；然后分别做了两次append操作，然后最后做一个toString()操作。**此时在堆中创建了StringBuilder的空间，效率低。**

 

**String的常用方法**

String类用于保存字符串常量，但由于每次更新都需要重新开辟空间，因此效率较低，为此java设计者提供了StringBuilder和StringBuffer用于增强功能，提高效率。

**重要**

`.length()`	返回字符串长度（数组的长度不需要括号）

`.charAt()`	获取某索引处的字符

`.substring(beginIndex,endIndex)`	截取指定范围的子串（左闭右开）(`.substring(beginIndex)`一个参数时重载截取从索引位置到字符串结尾的方法)

`.equals()`	区分大小，判断字符串内容是否相等

`.toCharArray()`	将字符串转换为字符数组（`String str = new String(charArray);`将字符数组再转换为字符串(刷题常用)）

**其他**

`.trim()`	去除字符串前后的空格；

`.indexOf(char c/String s)`	获取字符（也可以是字符串）在字符串**第一次**出现的索引，找不到则返回-1；

`.lastIndexOf(char c/String s)`	获取字符（也可以是字符串）在字符串**最后一次**出现的索引，找不到则返回-1；

`.toUpperCase()`和`toLowerCase()` 	将字符串常量变为全大写和全小写

`.replace(str ori,str des)`	将字符串所有的ori替换为des，返回替换过后的字符串。（注意：返回值才是进行替换过后的字符串，原字符串不会被操作）

`.split(char c)` 以c字符为标准分割字符串，返回字符串数组String[]。 （如果有特殊字符，需要加入转义符）

`.compareTo()`	比较两个字符串的大小（先比较第一个不一样字符的大小，如果没法找到则比较长度）

`String str = String.format(formatStr,param1,param2,...);`	formatStr为带有占位符的字符串



### **StringBuffer类**

StringBuffer，字符串缓冲区是一种线程安全，可变的字符序列。 字符串缓冲区类似于String ，但可以进行修改。 在任何时间点它都包含一些特定的字符序列，但序列的**长度和内容**可以通过某些方法调用来改变。

字符串缓冲区可供多个线程使用。 这些方法在必要时进行同步，以便任何特定实例上的所有操作都表现得好像它们以某个串行顺序出现，这与所涉及的每个单独线程所进行的方法调用的顺序一致。

在java中是一个**容器**。主要操作是append和insert方法。

特点：

(1) StringBuffer是final类，不能被继承；

(2) 实现了Serializable接口，即StringBuffer对象可以串行化；可以保存到文件或网络传输；

(3) 继承了抽象类AbstractStringBuilder，该抽象类中有一个属性char[] value（非final），用于存放字符序列；



**String和StringBuffer区别：**

(1) String保存字符串常量，不能被修改，**只能修改其地址**；

(2) String保存的字符串常量可以被修改，**可以更新其中的内容**，不用每次都更新地址（创建新对象），效率更高；

  

**构造方法**

(1) `StringBuffer s = new StringBuffer();`	创建一个初始大小为16的char[]字符数组，用于存放字符内容；

(2) `StringBuffer s = new StringBuffer(CharSequence seq);`	通过CharSequence构建一个存放seq的StringBuffer对象；

(3) `StringBuffer s = new StringBuffer(int capacity);`	构建一个指定初始容量的StringBuffer对象；

(4) `StringBuffer s = new StringBuffer(String str);`	通过String构建一个存放str的StringBuffer对象，容量为当前长度加16；



**常用方法**

(`.length()`/`.substring()`/`.indexOf()`/`.charAt()`等和String用法一致)

`.toString()`	将StringBuffer对象转换为String

`.append(String str)`	将str追加StringBuffer（可以一直在语句中追加；对对象本身进行修改；）

`.delete(int start,int end)`	删除StringBuffer索引从[start, end)的字符（左闭右开；对对象本身进行修改）

  `.replace(int start,int end,String str)`	使用str替换从索引[start, end)的内容（具体操作：首先删除指定范围内的字符，然后在start开始insert字符）

`.insert(int index, String str/int i)`	将str或整数i插入到索引为index的StringBuffer中

`.reverse()`	对StringBuffer实现反转操作



**注意事项：**

* 通过StringBuffer的append方法可以追加空值，此时会append("null")；而通过str传入构造器创建的StringBuffer中str不能为null，因为调用了super(str.length()+16)方法，会报空指针异常；



**StringBuilder类**

StringBuilder一种可变的字符序列。StringBuilder类提供了一个和StringBuffer兼容的API，但**不保证线程安全**，即没有synchronized关键字。主要使用在字符串缓冲区被**单个线程**使用的情况。

由于 StringBuilder 相较于 StringBuffer 有**速度优势**，所以多数情况下建议使用 StringBuilder 类。



**String、StringBuffer、StringBuilder比较**

后两者基本类似，均代表可变的字符序列，方法一致。StringBuffer效率较高但不如StringBuilder，线程安全；StringBuilder效率最高，但线程不安全。

String表示不可变字符序列，效率低，但**复用率高**（不需要在池中重复创建）；效率低主要体现在每次进行字符串拼接等操作时，会在新的空间创建字符串，导致大量副本字符串对象存留在内存中（自动回收机制销毁对象也需要时间），降低效率，如果放在循环中则效率更低。因此如果对字符串变量做大量修改，不建议使用String。



### **Arrays类**

**常用方法**

`Arrays.toString(int[] array)`	将数组转换为String用返回值接收  ，便于快速输出数组信息

`Arrays.sort(int[] array)`	对数组本身进行排序操作（数量小于47使用插入排序，大于286使用归并排序，在两者之间使用快速排序

`Arrays.binarySearch(int[] arr,Object o)`	通过二分查找查找val所在的索引，如果未查询到返回-(low+1)【应该插入的位置*(-1)】（要求数组为有序数组，当有多个相同的数值在数组中，无法正确找到该数值的最后一个数值的索引，或者第一个数值的索引。)

`Arrays.copyOf(int[] arr,int length)`	从arr数组中拷贝length个元素赋予返回值（如果length大于数组长度则会用默认值填充，如果length<0则抛出NegativeArraySizeException异常）

`Arrays.fill(int[] arr,Object element)`	用element填充arr的每个元素，对arr本身进行修改

`Arrays.equals(int[] arr1,int[] arr2)`	判断两个数组是否相同，返回布尔值

`Arrays.asList(param1,param2,...)`	将一组值转换成一个List集合，用返回值接收



### **自定义排序**

**Comparable接口和Comparator接口**

Comparable是**只**定义了compareTo方法的接口：`public int compareTo(T o);`；该接口可以通过泛型确定compareTo方法的形参类型。

**比较：**

* 若一个类实现了**Comparable接口**，就意味着“该类支持排序”。“实现Comparable接口的类的对象”可以用作“有序映射(如TreeMap)”中的键或“有序集合(TreeSet)”中的元素，而不需要指定比较器。实现该接口的类可以通过重写`compare(T o)`实现排序比较。

* **Comparator 接口**是比较器接口。我们若需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)；那么，我们可以建立一个“该类的比较器”来进行排序。我们可以通过“实现Comparator类来新建一个比较器”，然后通过该比较器对类进行排序。通过重写`int compare(T o1,T o2)`实现比较。

**结论：Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。**



**ArrayList实现自定义排序**

**语法：**`Arrays.sort(array,Comparator对象)`	通过实现**Comparator接口**自定义排序。



通过创建Comparator对象实现自定义的排序。

```java
public class demo1{
    public static void main(String[] args) {
        Person[] personArray = new Person[5];
        personArray[0] = new Person("a",18);
        personArray[1] = new Person("b",17);
        personArray[2] = new Person("c",18);

        Arrays.sort(personArray, new Comparator<Person>() {
            @Override
            public int compare(Person o1, Person o2) {
                return o1.getAge()-o2.getAge();//前-后为正序排列
            }
        });
    }
}

class Person{
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
        public int getAge() {
        return age;
    }
}
```

通过创建Comparator对象并实现Comparable接口实现自定义的排序。

```java
public class exercise {
    public static void main(String[] args) {
        ArrayList<Employee> employees = new ArrayList<>();
        employees.add(new Employee("twh", 10000, new Mydate(11, 3, 1997)));
        employees.add(new Employee("twh", 10000, new Mydate(11, 6, 1997)));
        employees.add(new Employee("xca", 8000, new Mydate(5, 2, 1995)));
        employees.add(new Employee("sjy", 9000, new Mydate(2, 1, 1998)));

        employees.sort(new Comparator<Employee>() {
            @Override
            public int compare(Employee o1, Employee o2) {
                int i = o1.getName().compareTo(o2.getName());
                if (i != 0) return i;
                return o1.getBirthday().compareTo(o2.getBirthday());
            }
        });
        System.out.println("employees" + employees);
    }
}

class Employee {
    private String name;
    private double sal;
    private Mydate birthday;

    public Employee(String name, double sal, Mydate birthday) {
        this.name = name;
        this.sal = sal;
        this.birthday = birthday;
    }

    public String getName() {
        return name;
    }

    public Mydate getBirthday() {
        return birthday;
    }

    @Override
    public String toString() {
        return "员工" +"姓名：'" + name + '\'' +", 工资：" + sal +", 生日：" + birthday;
    }
}

class Mydate implements Comparable<Mydate> {//<Mydate>是泛型的使用，确定并标识了compareTo方法中形参 对象的类型
    private int month;
    private int day;
    private int year;

    public Mydate(int month, int day, int year) {
        this.month = month;
        this.day = day;
        this.year = year;
    }

    public int getMonth() {
        return month;
    }

    public int getDay() {
        return day;
    }

    public int getYear() {
        return year;
    }

    @Override
    public String toString() {
        return getYear() + "/" + getMonth() + "/" + getDay();
    }

    @Override
    public int compareTo(Mydate o) {
        int y = year - o.getYear();
        if (y != 0) return y;
        int m = month - o.getMonth();
        if (m != 0) return m;
        return day - o.getDay();
    }
}
```



---



# 泛型

### 基本概念

Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了**编译时类型安全检测机制**，该机制允许程序员在编译时检测到非法的类型。

泛型的本质是**参数化类型**，一般在  在**类声明和实例化**时将操作的数据类型被指定为一个参数（泛型是数据类型的类型）。

**泛型的语法：**

声明：`interface i<T>{}`	或	`class c<K,V>{}`	其中T、K、V表示类型，任意字母都可。

举例：（容器ArrayList实例化）`List<String> strList = new ArrayList<>():`	只需要一边指定类型。



**泛型的作用：**

* 可以在类声明时，通过一个标识标识类中的**属性类型**，或者某个方法**返回值类型**，或者**参数类型**。

  ```java
  class Person<E>{//相当于将需要的类型传入到E中
  	public E name;//E标识name的数据类型，该数据类型在创建Person对象时确定（编译期间就确定E是什么类型）
  	
  	public E getName(E name){//E标识getName的返回值和name的参数类型
  		this.name = name;
  		return name;
  	}
  }
  ```

* 泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常，使得代码更简洁、健壮；

* 可以对加入到集合中的数据类型进行约束（安全）；
* 放入和取出集合中的对象时不需要进行类型转换，间接提高效率。



**泛型的细节：**

* **在类声明处**使用泛型如果为T或E，则**创建对象时**只能指定为引用类型，而不能为基本数据类型；
* **在类声明处**指定的具体类型可以传入该类型或其子类型（向上转型：形参为父类对象，实参可以用子类对象传入）； 
* 在实际开发中，往往不写等号右边的泛型（简写），只用<>代替，编译器自动进行类型推断；
* 如果我们不加泛型，例如：`List l = new ArrayList();`    则**默认泛型E=Object**；
* 泛型不具备继承性，例如不允许使用`List<Object> l = new ArrayList<String>();`





### 自定义泛型

**自定义泛型类**

**语法：**`class 类名<T,R,...>{...}`

**基本原则：**

* **泛型类的类型在创建对象的时候确定；**

* 类中的成员（属性、方法）可以使用泛型，属性依然可以使用构造器和setter、getter方法；

* 使用泛型的数组不能进行初始化（原因：数组在创建时如果使用泛型则不能确定存储元素的类型，这样无法自定义的开辟空间）；

* 静态属性的类型、静态方法中的返回值和参数都不能使用类的泛型（原因：泛型需要创建对象后才能确定数据类型，而静态成员在类的加载和创建时就放入内存，这将导致JVM无法完成初始化）；

  

**自定义泛型接口**

**语法：**`interface 接口名<T,R,...>{...}`

通过继承接口时指定泛型类型：`interface 接口名1 extends 接口名2<具体泛型类型1,...>{}`（此时该接口实现类的重写方法需要用指定的泛型类型去重写）

在实现接口时直接指定泛型类型：`class 类名 extends 接口名<具体泛型类型1,...>{}`

**基本原则：**

* **泛型接口的类型，在继承接口和实现接口的时候确定；**

* 接口中，静态成员也不能使用泛型；

  

**自定义泛型方法**

**语法：**（方法定义）`访问修饰符<T,R,...> 返回值类型 方法名(参数列表){}`	注意此处的泛型标识符只提供给方法使用，而不是类或接口中的标识符 

**基本原则：**

* 泛型方法可以定义在普通类中，也可以定义在泛型类中（要求泛型方法和泛型类的标识符不同）；
* 在泛型方法调用时：`对象名.方法名(实参列表)`，编译器会根据传入的实参类型自动为泛型方法中的标识符确定 类型；
* 泛型方法可以使用自己声明的泛型，也可以使用类/接口声明的泛型。

**注意事项：**

* `访问修饰符 返回值类型 方法名(T o1， R o2)`不是泛型方法而只是使用了类或接口定义的泛型；

  

e.g.

```java
class Fish<T,R>{
    public void eat(T t){}//不是泛型方法，只是使用了泛型
    
	public<U> void swim(U u,T t){}//要求泛型方法和泛型类的标识符不同;泛型方法可以使用自己声明的泛型，也可以使用类/接口声明的泛型
}
```



### **泛型通配符**

<?>：表示该类或方法支持任意泛型类型；

<? extends A>：表示支持A类以及A类的子类型，规定了泛型的上限；

<? super A>：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限；





































---



# 集合框架

### 基本概念

由于数组的诸多不便，java提供了集合。集合可以动态保存任意多个对象，且提供了一系列便于操作对象的方法（增删改查）。

数组的缺点：(1) 长度在一开始需要指定且不能修改；(2) 保存的数据必须是同一类型的元素；(3) 元素增加删除等操作十分麻烦。

Java 集合框架主要包括两种类型的**容器**，一种是**集合**（Collection），存储一个元素集合；另一种是**图**（Map），存储**键/值对映射**。尽管 Map 不是集合，但是它们完全整合在集合中。



**框架体系**

<img src="C:\Users\TRT\AppData\Roaming\Typora\typora-user-images\image-20220119212737442.png" alt="image-20220119212737442" style="zoom:50%;" />

集合类Collection，实现了Iterable接口。

Collection 接口又有 3 种子类型：**List、Set 和 Queue**，

再下面是一些抽象类，最后是具体实现类，有常用的**Vector、ArrayList、LinkedList**类实现**List接口**，有常用的**TreeSet、HashSet**类实现了**Set接口**。有常用的**HashMap、Hashtable、TreeMap**类实现了**Map接口**。



**实现类的特点**

(1) Collection实现子类可以存放多个元素，每个元素可以为Object；

(2) 有些实现类可以存放重复的元素，有些不可以；

(3) 有些实现类是有序的（如List），有些是无序的（如Set）；



### 迭代器

由于Collection类**继承了Iterable接口**，实现了Collection接口的类都可以**使用Iterator迭代器**。

迭代器概念：interator对象称为迭代器，主要用于遍历集合中的元素（该对象本身并不用来存放对象）；所有实现了Collection接口的集合类都有一个`Iterator()`方法，用于返回一个实现了Iterator接口的迭代器。 

定义构造器方法：`Iterator<T> iter =col.iterator(); `	col指某个运行类型为实现类的对象，T表示需要遍历的集合元素属性

重置迭代器：`iter = col.iterator();`



**迭代器的执行原理**

```java
Iterator iterator = coll.iterator();
while(iterator.hasNext()){//判断是否还有下一个元素(必须加，否则报NoSuchElementException异常）
    System.out.println(iterator.next());//指针移动并返回移动后指向的元素
}
```



**迭代器常用方法**

`.hasNext()`	如果迭代器指向位置后面还有元素，则返回 `true``，否则返回false`

`.next()`	指针向后移动并返回移动后指向的元素

`.remove()`	删除当前指针所指向的元素，一般和next方法一起用，这时候的作用就是删除next方法返回的元素



**增强for:**

增强for又被称为foreach。Collection的实现类和数组都可以使用增强for，增强for的底层仍然是迭代器。

语法：for(type element:coll){...}

* 对element进行赋值无法真正改变coll的值，因为底层代码先创建了一个迭代器对象，将.next()方法的返回值转型后赋予element，因此修改element并不能修改容器中的内容；
* 如果element为一个对象，则要写出他所指向的类名；



### List接口

**基本概念**

List接口是Collection的子接口。

**特点：**(1) List集合类中的元素有序且可以重复（添加和取出的顺序需要一致）；(2) List集合类的每个元素有其对应的顺序索引；

常用的实现类有：ArrayList、LinkedList、Vector



**遍历方式**

```java
Iterator iterator = list.iterator();
while (iterator.hasNext()) {//迭代器遍历
    Object obj =  iterator.next();
    System.out.println(obj);
}
for (Object o : list) {//增强for
    System.out.println("o=" + o);
}
for (int i = 0; i < list.size(); i++) {//普通for
    System.out.println("对象=" + list.get(i));
}
```

**常用方法**

(1) 查看和访问

`.size()`	计算List中元素的数量

`.get(int index)`	访问第index个元素

`.contains(Object o)`	判断元素是否存在，返回布尔值

`.isEmpty()`	判断ArrayList是否为空，返回布尔值

`.subList(int fromIndex, int toIndex)`	返回索引间的子集合（左闭右开）

(2) 修改元素（增删改查）

`.add(Object o)`	添加单个元素到List末尾

`.add(int index, Object o)`	在指定index添加元素，index以及之后的元素往右移动

`.addAll(Collection c)`	添加某一集合中的所有元素到 List中

`.set(int index, Object o)`	修改第index个元素的值（如果index超过范围则会报索引越界异常）

`.remove(int index)`	删除第index个元素，返回被删除的对象

`.remove(Object o)`	删除第一次出现的该元素，返回true；如果不存在则不变，返回false

`.clear()`	清空List的元素



 **注意事项：**

* 在List的内部，每个元素都是以Object的对象的形式进行存储的，如果需要**使用其任意实现类的方法，必须使用泛型或先进行向下转型**；
* List是一个抽象类（接口），不能用List作为运行类型创建对象，需要**用向上转型的方法创建实现类的对象**；



#### ArrayList类

ArrayList 类是一个**可以动态修改的数组**，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。

**结构：**ArrayList 继承了 AbstractList，并实现了 List 接口（拥有List接口的所有方法），以及Serializable, Cloneable, RandomAccess接口。

**特点：**

* ArrayList中可以存放null元素；
* ArrayList的底层是用数组进行数据存储的；
* ArrayList基本等同于Vector，但ArrayList的**执行效率更高**，但**线程不安全**。

<img src="C:\Users\TRT\AppData\Roaming\Typora\typora-user-images\image-20220119214137257.png" alt="image-20220119214137257" style="zoom:50%;" />



**底层实现**

ArrayList中维护了一个Object类型的数组elementData（elementData用transient修饰，表示该属性不会被序列化）

当创建ArrayList对象时，如果使用的是无参构造器，则初始化elementData的容量为0，第一次添加则扩容elementData到10，之后每次需要扩容则扩容到原来的1.5倍；如果使用有参构造器指定ArrayList的容量，则每次需要扩容时扩容到原来的1.5倍。（**每次扩容是扩容底层的elementData而不是扩容ArrayList**)



使用**无参构造器**创建数组并添加元素时ArrayList的底层**执行步骤**：

(1) 创建元素时会创建一个空的elementData数组；

(2) 对添加的元素进行装箱操作（装箱为某一包装类）；

(3) 首先调用`ensureCapacityInternal(size+1)`确认是否需要扩容，再执行添加操作`elementData[size++]=e`；

(4) `ensureCapacityInternal(size+1)`内部会记录集合被修改的次数，并判断`elementData.length`是否小于`size+1`，如果小于代表容量不够则使用`grow(size+1)`方法进行扩容；

(5) `grow(size+1)`方法会使用`Arrays.copyOf()`方法创建一个比原先数组大0.5倍的elementData数组。（多余的位置用null填充)



使用**有参构造器**创建数组并添加元素与无参构造器的异同（其他一致）：

(1) 在构造器中不再创建一个空的elementData数组，而是创建指定大小的数组；

(2) 直接扩容elementData数组的容量至1.5倍。



#### Vector类

Vector底层也是一个对象数组：`protected Object[] elementData`.

**结构：**Vector继承了 AbstractList，并实现了 List 接口（拥有List接口的所有方法），以及Serializable, Cloneable, RandomAccess接口。

**特点：**(1) **线程安全**，但效率不高。

<img src="C:\Users\TRT\AppData\Roaming\Typora\typora-user-images\image-20220120204842603.png" alt="image-20220120204842603" style="zoom:50%;" />



**底层机制**

当创建Vector对象时，如果使用的是无参构造器，则初始化elementData的容量为0，第一次添加则扩容elementData到10，之后每次需要扩容则扩容到原来的2倍；如果使用有参构造器指定Vector的容量，则每次需要扩容时扩容到原来的2倍。（**每次扩容是扩容底层的elementData而不是扩容Vector**)



#### LinkedList类

链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。可以添加任意元素（元素可以重复，包括null）

一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。

LinkedList（链表） 类似于 ArrayList，是一种常用的数据**容器**。

**特点：**与 ArrayList 相比，LinkedList 的**增加和删除的操作效率更高**，而**查找和修改的操作效率较低**。



**底层机制**

LinkedList底层实现了**双向链表**，属性中维护了两个属性first和last指向首节点和尾节点，每个节点（Node对象）又维护了prev、next、item三个属性值（prev指向前一个节点，next指向后一个节点，item用于真正存放节点数据）



**LinkedList和ArrayList的使用情况对比：**

以下情况使用 ArrayList :

(1) 频繁访问列表中的某一个元素(**最多的操作，所以一般使用ArrayList**)；(2) 只需要在列表末尾进行添加和删除元素操作。

以下情况使用 LinkedList :

(1) 需要通过循环迭代来访问列表中的某些元素；(2) 需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。



### Set接口

List接口是Collection的子接口。

特点：(1) 无序（添加和取出的顺序不一致，但是是固定的），没有索引；(2) 不允许重复元素或对象，最多只包含一个null；

**遍历方式：**(1) 使用迭代器；(2) 使用foreach遍历**（不能使用索引获取其中的元素，也就是说没有get方法）**

```java
Iterator iterator = set.iterator();//用迭代器遍历
while(iterator.hasNext){
    Object obj = iterator.next();
    System.out.println(obj);
}
for(Object o : set){//使用增强for遍历
    System.out.println(o);
}
```

**常用方法：**

(1) 修改元素（增删改查）

`boolean add(Object o)`	添加单个元素到Set（不确定位置）（返回值判断是否添加成功，如果重复则添加失败）

`boolean remove(Object o)`	删除第一次出现的该元素，返回true；如果不存在则不变，返回false

`void clear()`	清空Set的元素

(2) 查看和访问

`int size()`	计算Set中元素的数量

`boolean contains(Object o)`	判断元素是否存在某元素

`boolean isEmpty()`	判断Set是否为空

`Iterator<E> iterator()`	返回该Set的迭代器对象



#### HashSet类

HashSet实现了Set接口，实际上底层是**基于 HashMap** 来实现的，是一个不允许有重复元素的集合。HashSet 不是线程安全的。

特点：(1) 最多只能存放一个null值；(2) 无序，hash后才能确定索引的结果；(3) 不能有重复的元素或对象（注意不同的对象值不同的地址）。



**底层机制**

* HashSet的底层是HashMap，HashMap的底层是**数组+链表+红黑树**。（红黑树具有极高的查询速度）

* 添加元素步骤：
  1. 创建HashSet：实际在底层创建一个空的HashMap：`private transient HashMap<E,Object> map = new HashMap<>();`
  2. 添加一个元素后，先通过`hashCode()`和一些计算得到hash值，通过计算得到一个**索引值p**（放在哈希表中的位置号）；
  3. 找到**存储数据表table**，看索引位置是否已经存放元素，如果没有则在该索引位置创建一个**链表头Node**，如果有则调用equals方法；
  4. 用equals方法**（程序员确定）**比较链表各节点的值， 如果相同则放弃添加，如果不同则添加到该索引所存储链表的末尾；

* 扩容机制：第一次添加扩容table容量到16，临界值为16*0.75=12,。每次到达临界值则扩容table到原来大小的两倍(32)，临界值也扩大到原来的两倍(24)；

* 树化条件：在jdk8中，如果一条链表的元素个数大于等于8，并且table大小大于等于36，就会进行（红黑）树化（jdk7没有这一操作），如果table大小不足36，则扩容table为两倍；   



**具体底层实现：**

底层（跳转部分）：

```java
//1. 执行 HashSet()
    public HashSet() {
        map = new HashMap<>();//在底层创建一个HashMap
    }
//2. 执行 add("java")
   public boolean add(E e) {//e = "java"
       	//PRESENT是一个占位符常量，public static final Object PRESENT = new Object(); 
        return map.put(e, PRESENT)==null;//判断是否添加成功
   }
//3.执行 put() , 该方法会执行 hash(key) 得到key对应的hash值 算法h = key.hashCode()) ^ (h >>> 16)
     public V put(K key, V value) {//key = "java" value = PRESENT value在每个索引位置的每个节点都共享
        return putVal(hash(key), key, value, false, true);
    }

```

底层（核心代码）：

```java
//4.执行 putVal（重点）
 final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
           boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i; //定义了辅助变量(tab存放当前的数据存储表，p存放某个索引下链表的某个Node)
        //table 就是 HashMap 的一个数组，类型是 Node[]。如果当前table为空或大小=0就第一次扩容到16个空间
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;//扩容（容量初始值为16，扩容的临界值为当前数组容量(16)*loadFactor(0.75)=12)
     
        //根据key，得到hash，去计算该key应该存放到table表的哪个索引位置，并把这个位置的对象，赋给辅助变量p
     	//p如果为null, 表示还没有存放元素, 就调用newNode方法创建一个Node (key="xxx",value=PRESENT)，放在该位置 tab[i]
        if ((p = tab[i = (n - 1) & hash]) == null)//(n-1)&hash 是通过hash计算出的索引
            tab[i] = newNode(hash, key, value, null);
     	//如果不为null，有则判断该值的索引位置是否为链表
        else { 
            Node<K,V> e; K k; //辅助变量（e用于保存重复情况下的Node（如果不重复则为null），k用于保存第一个node的key
            //如果当前索引位置对应的链表的第一个元素（有多个元素时走else语句）和准备添加的key的hash值一样
            //并且满足下面两个条件之一，就不能加入:
            //(1) 准备加入Node的key和p指向的Node的key是同一个对象
            //(2) p指向的Node结点的key的equals()和准备加入的key比较后相同
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
            //再判断 p 是不是一棵红黑树,如果是一棵红黑树，就调用 putTreeVal方法来进行添加
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            ////如果table对应索引位置，已经是一个链表, 就使用for循环比较
            else {
                for (int binCount = 0; ; ++binCount) {//死循环
                    //如果下一个节点为空（遍历完该链表均没有相同的值），则创建新节点到链表的最后，跳出该循环
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount >= TREEIFY_THRESHOLD(8) - 1) // 把元素添加到链表后，立即判断该链表是否已经达到8个结点
                            treeifyBin(tab, hash);//如果到达8个，并且table的容量小于64，则先扩容；大于64时才转换成红黑树
                        break;
                    }
                    //如果有key相同情况，就直接跳出该循环
                    //第一个节点已经在第一个if中比较过，直接比较第二个元素
                    if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;//p指针向后移动一位
                }
            }
            if (e != null) {//做替换工作
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size > threshold)//每加入一个结点Node(k,v,h,next), size++（注意size是由总节点个数决定，而不是索引占位数）
            resize();//扩容
        afterNodeInsertion(evict);//针对hashmap的子方法进行修改的方法（在hashmap中为空方法）
        return null;
    }
```



### Map接口

Map接口比Set接口使用的更为广泛。常用实现类包括：HashMap（最最频繁）, Hashtable和Properties.

Map与Collection并列存在，用于保存具有映射关系的数据Key-Value。（双列元素）

**特点：**

(1) Map中的key和value可以是任何**引用类型**的数据（如果传入基本数据类型，则编译器会自动装箱为包装类），会封装到**HashMap$Node对象**中;

(2) Map中的**key不允许重复**，而**value允许重复**。如果put的key相同，则后添加的value值会覆盖该key原来对应的value值（等同于修改）；

(3) Map的key常用String类型；

(4) key和value存在单向一对一的关系，通过指定的key总能找到相应的value；



**常用方法：**

(1) 增删改查

`V get(Object key)`	通过指定key获取value；

`V put(K key, V value)`	向集合中添加元素，若key已重复则覆盖原value	（如果重复则返回被替换的value，如果不相同返回null）；

`V remove(Object key)`	删除指定key的键值对；

`void clear()`	清空集合，元素个数变为0；

`default boolean replace(K key, V oldValue, V newValue)`	修改键值对<key, oldValue>的value为newValue；

(2) 属性和判断

`int size()`	获取集合中元素的个数；

`boolean isEmpty()`	判断集合元素个数是否为0；

`boolean containsKey(Object key)`	判断集合中是否包含指定key；

`boolean containsValue(Object value)`	判断集合中是否包含指定value；注意：contains()方法底层都调用了equals()方法，可以自定义



**遍历方式：**

`Set<Map.Entry<K,V>> entrySet()`	将Map集合转换成Set集合；

`Set<泛型> keySet()`	获取集合中所有的key，返回一个包含所有key元素的Set集合；

`Collection values()`	获取集合中所有的value，返回一个包含所有value元素的Collection集合（基本不用，没有map的价值）；

代码：

```java
//用KeySet遍历（需要多做一步：通过key取出map中的value）
Set<String> ms = map.keySet();
for(String s:ms){//使用增强循环遍历
    System.out.println(s+"-"+map.get(s));
}
Iterator<String> iterator = ms.iterator();//使用迭代器遍历
while(iterator.hasNext()){
    String next = iterator.next();
    System.out.println(next+"-"+map.get(next));
}
//用entrySet遍历
Set<Map.Entry<String, String>> entries = map.entrySet();
for(Map.Entry<String, String> s:entries){
    System.out.println(s.getKey()+"-"+s.getValue());
}
```



**底层机制**

* Map的一对k-v**（也被称为一个Entry）**实际上存放在一个**HashMap$Node对象**中：`HashMap$Node node = newNode(hash,key,value,null);`； 

* 为了便于程序员的遍历，HashMap定义了一个entrySet集合用于存储每个Node：`transient Set<Map.Entry<K,V>> entrySet;`	
* entrySet中定义的类型是Map.Entry，但实际存放的类型是HashMap$Node（这里相当于将HashMap$Node的对象赋值给了Map.Entry，发生了向上转型【Node实现了Map.Entry】）；

* 在Map.Entry中提供了getKey()和getValue()方法，用于遍历显示；



#### HashMap类

HashMap实现了Map接口，是Map接口中使用最多的实现类。根据键的 HashCode 值存储数据，具有很快的访问速度。

**特点：**

(1) 同Map接口；

(2) key和value均可以为空，但key如果出现第二个为空，value会发生替换；

(2) 由于底层是通过计算hash()等方法计算存储索引位置的，因此不能保证映射的顺序（同HashSet）；

(3) 不支持线程同步（方法没有做同步互斥操作）。



**底层机制**

（和HashSet相似）

* HashMap底层维护着一个`HashMap$Node[]`类型的数组table，默认为null；

* 创建和添加步骤：
  1. 当创建对象时，初始化加载因子loadfactor=0.75；
  2. 当添加key-val时，通过**key的哈希值**得到该Node在table的索引，并判断该索引有没有元素：
  3. 如果没有则直接添加，如果有则继续判断该元素的key和需要添加的key是否相等；
  4. 如果相等则**替换**原来的val，如 果不相等需要判断是树结构还是链表结构，做添加元素处理；

* 扩容机制：第一次添加扩容table容量到16，临界值为16*0.75=12。每次到达临界值则扩容table到原来大小的两倍(32)，临界值也扩大到原来的两倍(24)； 

* 树化条件：如果某条链表元素超过8个，但table的size不足64个，则每次比8多加一个就扩容一倍（最多扩容两次）；如果size也大于等于64，则进行树化。



#### Hashtable类

Hashtable实现了Map接口。使用方法和HashMap基本一致。

**特点：**

(1) 同Map接口；

(2) hashtable的**键和值都不能为null**，否则报NullPointerException；

(3) 支持线程同步，是**线程安全**的；但效率比HashMap低；



**底层机制：**

* Hashtable底层维护了一个`Hashtable$Entry[]`类型的数组table，初始大小为11；

* 创建并添加值的步骤：
  1. 创建Hashtable时，初始化table的大小initialCapacity=11、加载因子：loadFactor=0.75和临界值threshold=（int)11*0.75=8；
  2. put方法首先判断val是否为空，如果发现是null，则直接抛出异常；
  3. 计算key的哈希值，并通过计算得到新加入Entry在table中的索引；
  4. 遍历对应位置的链表，如果发现已经存在相同的hash和key，则更新value，并返回旧值；
  5. 如果不存在相同的key的Entry节点，则调用addEntry方法增加节点，记录添加到次数count。

* 扩容机制：当count大于等于threshold，则进行扩容：按`newCapacity = (oldCapacity << 1) + 1`进行扩容(×2+1)；



#### Properties类

Properties 继承于 Hashtable，并继承了Map接口。用键值对的形式保存数据。属性列表中每个键及其对应值都是一个字符串。

使用特点和Hashtable一致。

Properties可以用于从xxx.properties文件（作为配置文件）中加载数据到Properties类对象，并进行读取和修改； 



### 集合实现类的选择

主要根据业务操作特点选择集合实现类。

**主要依据**

(1) 先判断存储的类型（是一组对象【单列】还是一组键值对【双列】）

(2) 单列：考虑是否允许重复（Set/List） 双列：考虑Map

(3) 选择List判断是增删多(LinkedList，底层维护双向链表)还是改查多(ArrayList，底层维护Object可变数组)

(4) 选择Set判断是否有序(TreeSet/HashSet)

(5) 选择Map判断键是否有序（HashMap/TreeMap)，读取文件使用Properties



### Collection工具类

Collection工具类提供了一系列静态方法对集合元素进行排序、查找和修改等操作。

**排序操作**

`reverse(List)`	反转 List 中元素的顺序

`shuffle(List)`	对 List 集合元素进行随机排序

`sort(List)`	根据元素的自然顺序对指定 List 集合元素按升序排序

`sort(List，Comparator)`	根据指定的 Comparator 产生的顺序对 List 集合元素进行排序

`swap(List，int， int)`	将指定 list 集合中的 i 处元素和 j 处元素进行交换

**查找、替换**

`Object max(Collection)`	根据元素的自然顺序，返回给定集合中的最大元素

`Object max(Collection，Comparator)`	根据 Comparator 指定的顺序，返回给定集合中的最大元素

`Object min(Collection)`	根据元素的自然顺序，返回给定集合中的最小元素

`Object min(Collection，Comparator)`	根据 Comparator 指定的顺序，返回给定集合中的最小元素

`int frequency(Collection，Object)`	返回指定集合中指定元素的出现次数

`boolean replaceAll(List list，Object oldVal，Object newVal)`	使用新值替换 List 对象的所有旧值