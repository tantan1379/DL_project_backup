# 随笔

## 小知识

* **左值**的意思就是可以放在等式左边的值；

* **==**前后颠倒的作用：当我们使用==判断符号时：等号左边写常量，使用NULL == xxx，而不是xxx == NULL；判断时，等号左边写常量，等号右边写变量，防止少写一个等号带来的严重BUG；

* **#pragma once**的作用：防止头文件重复包含；

* **static**关键词的作用：**static修饰的变量只会被初始化一次**（若静态变量在定义时未显式地指定初值，则自动初始化为相应类型的**零值**<隐式初始化>）但可以被多次赋值对该变量进行修改；注意初始化是在编译时进行，变量的赋值是在函数或程序运行时进行；

* C/C++程序编译的各个阶段：

  * **预处理阶段：**根据以字符#开头的命令，修改原始的C程序。比如hello.c中第一行的#include<stdio.h>命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文本中，结果就得到了另一个C程序，通常是以.i作为文件扩展名。
  * **编译阶段：**编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序。汇编语言程序中的每条语句都以一种标准的文本格式确切的描述了一条低级机器语言指令。
  * **汇编阶段：**汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成一种可重定位目标程序的格式，并将结果保存在目标文件hello.o中。hello.o文件是一个二进制文件，它的字节编码是机器语言指令而不是字符，如果我们在文本文件中打开hello.o文件，看到的将是一堆乱码。
  * **链接阶段：**链接器（ld）负责处理合并目标代码，生成一个可执行目标文件，可以被加载到内存中，由系统执行。

* **const**和**define**的区别:   

  * define是在**预处理阶段**展开，const是在**编译运行阶段**使用；
  * define宏定义没有类型，不做任何类型检查而仅仅是展开。const常量有具体的类型，在编译阶段会执行类型检查；
  * const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define 定义的常量在内存中有若干个拷贝；
  * 编译器通常不为普通const 常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高； 

* `char a[]="abcd"`实际上定义了一个字符数组在栈中，再将字符串常量“abcd”的值copy给栈区的字符数组；

* 全局变量、局部变量、全局静态变量的区别:

* 全局变量作用于整个项目，只需要在一个源文件中定义就可以作用于所有的源文件，其它不包括全局变量定义的文件需要用`extern`关键字再次声明这个全局变量;而全局静态变量仅作用于当前源文件；

* 全局变量（无论是否静态）都会被编译器自动初始化为0；而局部变量如果不初始化会报错；   

* 函数的大括号后可以不用加“;"，不影响程序运行。因为当编译器读到“}”时就知道了函数的结束，";"会被认为为一个空语句；

* 使用cin.get(s1, num)时，num会包含一个回车号的位置；

  



## C与C++的差别

**1、NULL和nullptr的区别：**

C：在C语言中，NULL被定义为：`#define NULL` ((void *)0)，不存在二义性

C++：NULL是一种宏定义，在C++的`stddef.h`头文件中，NULL被定义为常量0或无类型指针(void*)，存在二义性；
`nullptr`是C++11新出的定义，不包含于头文件中，属于一种关键字，nullptr仅代表一个指针变量

**总结：**为提高代码的健壮性，我们通常使用`nullptr`表示指针空值

**2、struct和typedef的区别：**

在C语言中声明一种结构的变量不能省略`struct`，而在C++中可以省略；

在C语言结构体定义时，如果加上``typedef`，可以在声明结构体变量时也可以省略struct，表示这是一种新的包含`struct`的别名。




## 运算符优先级

1、第一梯队：
[] 数组下标 
() 圆括号
. 成员选择（对象）
-> 成员选择（指针）   

2、第二梯队:
负号运算符 {-}
强制类型转换 (类型) 
自增运算符 ++ 
自减运算符 -- 
取值运算符 {*}
取地址运算符 &
逻辑非运算符 {!}
按位取反运算符 ~
长度运算符 sizeof    

3、第三梯队：
乘 * 除 / 余数 %

4、第四梯队: 
加 + 减 -

5、第五梯队：
左移<< 右移>>

6、第六梯队：
大小于判断

7、第七梯队：
逻辑与或异或 > == & |

8、第八梯队：
条件运算符 ?:

9、第九梯队：
赋值运算符 = /= +=...

10、第十梯队：
逗号运算符 ,

********************************************************************************************************************

---

---

# Basic

## 1、基础

**打印和基本框架:** 
`cout<<...<<...<<endl`用于打印内容，并进行换行，如果没有endl则不换行且继续打印
`system('pause')` `system('PAUSE')`用于等待用户信号，在控制台输出 “请按任意键继续...”，由于dos命令不区分大小写，因此两者作用相同

**输入：**
`cin >> ...`表示等待输入，赋值给...

**常量与变量:**
常量与变量不同，常量不可更改，可用`#define`和`const`定义

**标识符命名规则：**
1.标识符不可以为关键字；
2.可由字母数字和下划线构成，第一个字符只能是字母或下划线； 
3.标识符区分大小写。  

**运算符：**
(2)递增递减：num++和++num的区别在于，在表达式中++num是先算表达式再自加的，而num++相反。
(3)三目运算符
`f1 ? f2 : f3;`判断f1，若为True返回f2，若为False返回f3，注意该运算符通常用于赋值给一个变量
(4)`rand()%100`生成0-99的随机数，需要添加随机种子，避免伪随机情况`srand((unsigned int)time(NULL))`



---

## 2、数据类型

存在意义：给变量分配合适的内存空间
用`sizeof()`可以得到数据类型所占的内存大小，单位为字节 
**1、整型：**
short(2byte) 范围：-32768到32767 若超出右边界，则从左边界继续计数（物极必反）
int(4byte) 范围：-2^31到2^31-1 
long(4byte) 范围：-2^31到2^31-1 
long long(8byte) 范围：-2^63到2^63-1 
**2、实型：**
float(4byte) 范围：7位有效数字 
double(8byte) 范围：15~16位有效数字
**Note:**
1.默认情况下，C++中输出一个小数只会输出6位有效数字；
2.科学计数法，在数字整数部分后面加e；
3.C++中默认小数为double类型，通常在小数后加f表示数字是单精度的。
**3、字符型：**
char(1byte)
**Note:**
1.字符型变量存放的是ASCII码，0-31位控制型字符，32-126位键盘上存在的字符；
2.必须用单引号创建字符型变量；
3.(int)ch可以输出字符所对应的ASCII码。
**4、字符串型：** 
输出格式：
(1)`char str[]="default"`注意加[],字符串用双引号包含字符串内容
(2)`string str2 = "default2"`最好加上`#include <string>`
**5、布尔型：**
bool(1byte)
**6、转义字符:**
`\t`用于输出的整齐。作用实际上是填充原字符至8个字符，不足则补空格至8位，为8则加8个空格，超过了就按8为周期重新算。

---

## 3、程序流程结构

C/C++支持顺序结构、选择结构、循环结构

### 1、选择结构：

(1)if:略
(2)switch:

```   C++
switch(flag){
    case a:f1;break;
    case b:f2;break;
    default:f3;break;
}
```

**Note:**
1.switch的flag只能为整型或者字符，不可以为区间，而if可以
2.switch比if效率高

### 2、循环结构：

形式：for (表达式1; 表达式2; 表达式3)

for循环执行流程：
（1）求解表达式1；（只执行一次）
（2）求解表达式2。若其值为真，则执行 for 语句中指定的内嵌语句，然后执行第3步；若表达式2值为假，则结束循环，转到第5步；
（3）求解表达式3；（每次执行完循环体的内容再让i++)
（4）转回上面第2步继续执行；
（5）循环结束，执行 for 语句下面的语句。

(1)do...while是先执行代码块再进行while的判断，所以代码块至少执行一次；而while会先判断条件是否满足。
(2)`for(;;){}`和`while(1){}`的效果相同
(3)`for(f1;f2;f3){}`for循环中f1只执行一次

### **3、其他**

(1)break用于跳出一层循环；continue用于跳过本次循环，直接进行下一次循环；
(2)goto语句用于跳转到指定标志的地方，会跳过中间的部分。

---

## 4、数组

#### 4.1 一维数组：

一维数组的定义方法：
数据类型 数组名[数组长度]; 
数据类型 数组名[数组长度]={值1，值2...};  //如果值的数量少于数组长度则将数据未赋值部分设为0 
数据类型 数组名[]={值1，值2...}; 
**Notes:**
(1)数组的各个元素都放在连续的内存空间中；
(2)数组中每个元素都具有相同的数据类型，和定义的数组类型一致；
(3)定义数组时必须要有初始长度；
(4)如果定义数组的方法为`int arr[]={...}`，则可以用`sizeof(arr)/sizeof(arr[0])`来求数组的元素，如果给定数组长度，则不可以使用；
(5)如果打印数组的名字arr，和打印&arr[0]结果是一样的；
(6)**数组名是一个常量，是不能被修改的左值。** 利用数组名可以查看数组的内存空间和首地址。而如果需要查看除首元素外某个数组元素的地址，需要加&。note:arr=&arr=&arr[0]  

#### 4.2 二维数组：

二维数组的定义方法：
数组类型 数组名[行数][列数]; 
数组类型 数组名[行数][列数]={{1,2,},{3,4}}; 
数组类型 数组名[行数][列数]={1,2,3,4}; 
数组类型 数组名[][列数]={1,2,3,4}; 
**Notes:**
(1)利用数组名可以查看二维数组的内存空间，也可以获取二维数组的首地址。
(2)利用`sizeof(arr)/sizeof(arr[0])`可以提取行数，利用`sizeof(arr[0])/sizeof(arr[0][0])`可以提取列数。

---

## 5、函数

**函数声明：**
提前告诉编译器函数的存在。函数的声明可以写多次，但定义只能有一次。
**分文件编写：**
1、创建头文件，在头文件中对函数进行声明。  
2、创建函数源文件，对函数进行定义，同时#include相应的头文件。

---

## 6、指针

**定义指针：**  

```C++
int a = 10;
int *p;
p = &a;
//一步完成：
//int *p=&a
```

**使用指针：**

```C++
int a = 10;
int *p = &a;
*p = 1000;
//此时通过给*p赋值，修改了a的值
```

**空指针：**
`int *p = NULL;`
指向内存中编号为0的空间的指针称为空指针。作用主要是用于**初始化指针变量**，初始化指针属于程序员的素养。

**野指针：**

```C++
int *p = (int*)0x1100;
cout << *p << endl; //报错：（野指针异常）读取访问权限冲突
```

指针变量指向非法的内存空间称为野指针。

#### 6.1 const修饰指针（常量指针）：

```C++
const int* p = &a;
p = &b;//正确
*p = 20;//报错：表达式必须为可修改的左值
```

**指针的指向可以修改，但指针指向的值不可以被修改。**
记忆方法：const在int*前，const修饰的是指针p指向的内容，也就是说指针指向的内容不能随便修改，所以叫（只能指向）常量（的）指针

#### 6.2 const修饰常量（指针常量）：  

```C++
int * const p = &a;
p = &b;//报错：表达式必须为可修改的左值
*p = 20;//正确
```

**指针的指向不可以修改，但指针指向的值可以修改。**
记忆方法：const在p前，所以const修饰的是指针本身，指针的作用就是指向，而现在指针不能随便指向，丧失基本作用，指针也就只能沦为指针常量

#### 6.3 const修饰指针和常量:   

`const int * const p = &a;`
指针的指向和指针指向的值都不可以被修改。

**Notes:**
1、星号的作用是**解引用**，通过解引用可以找到指针变量所指向的内存，同时可以修改该内存；而&的作用是**取地址** ； 
2、32位操作系统下，所有指针都占4个字节，如一块连续的内存空间，用指针访问可以发现每个元素的地址依次加4；64位操作系统下，所有指针都占8个字符。
3、空指针指向的内存不可以被访问。实际上0-255之间内存编号都是系统占用的，均不可以被访问。
4、当我们为函数传入数组时，形参位置传入的实参应是数组的首地址，形参类型为指向数组元素类型的指针，可以写*arr或arr[]。因为不能拷贝数组，无法用值传递的方法传入数组，所以这里用的是地址传递。

---

## 7、结构体

#### 7.1 结构体：

结构体属于用户自定义的数据类型。声明结构体类型仅仅是声明了一个类型，**系统并不为之分配内存**。
结构体的定义：**struct 结构体名 { 结构体成员列表 }** 
通过结构体创建变量的方法：
1、struct 结构体名 结构体变量; 
2、struct 结构体名 结构体变量 = { 各个成员对应的值(value) }; 
3、定义结构体同时顺便创建结构体变量：struct 结构体名 { 结构体成员列表 } 结构体变量;    

### 7.2 结构体数组：

将多个自定义的结构体变量存放在数组中。
结构体数组的定义：**struct 结构体名 数组名[元素个数] = {}**

### 7.3 结构体指针

定义方法：**结构体名* 结构体指针 = &结构体变量**
此时该结构体指针指向该结构体变量，可以利用指针访问结构体变量中的数据。

### 7.4 结构体嵌套：

在一个结构体中包含另一个结构体作为成员：必须以级联方式逐级找到最底层成员再访问。

### 7.5 结构体作为参数进行传递：

传递方式：
1、**值传递**:用结构体变量作为形参，不会影响相应实参结构体的值，参数传递时会把实参的一份副本传给形参；

```C++
void print_structure_value(student s) {
    s.name = "bcd";  
    cout << s.name << endl;
}
```

2、**引用传递**:函数中用结构体数组或结构体指针作为形参，结构体变量的地址作为实参。此时在函数中修改结构体的内容会影响实参结构体的值。因为只复制了结构体首地址给函数的实参，因而**有较高的传递效率**。如果不想改变原实参中的结构体，可以在形参前加const（变为常量指针）。

```C++
void print_structure_address(student* s) {
  	s->name = "bcd";
  	cout << s->name << endl;
}
```

**Notes:** 
1、利用 ‘.’ 运算符直接可以访问结构体变量的属性：**结构体变量.属性**；利用 ‘->’ 可以访问结构体指针内的属性:**结构体指针->属性**；实际上，**结构体指针->属性** 相当于**(*结构体指针).属性**，注意(*指针)一定要括起来 。

```C++
//e.g.
s1 = {"abc", 1, 2};
s2[2] = {{"def",3,4},{"ghj",5,6}};
student* p1 = &s1;
student* p2 = s2; //结构体数组可以用数组名表示首元素地址
cout << p1->name << endl;
cout << p2->name << endl;
```

2、无名结构体通常用于函数内部。当只需要一个结构体变量，而不需要使用该结构体定义更多其他的变量时才能使用无名结构体；
3、声明结构体类型仅仅是声明了一个类型，系统并不为之分配内存。只有当使用这个类型定义了变量时，系统才会为变量分配内存。所以在声明结构体类型的时候，不可以对里面的变量进行初始化；
4、嵌套在结构体内的结构体需要定义在前面；
5、`struct a {} a1;`和`typedef struct b {} b1;`其中a1和b1的种类不同，a1为结构体变量，而b1为一种结构体类型，相当于`struct b` 。 
6、如果将函数的形参部分是结构体指针，如`BOOKS* abs`，则在该函数下使用结构体指针变量`abs`就代表了该结构体的地址，而不用再写`&abs`。



---

---

---

# Prime

## 1、内存分区

C++程序在执行时，可以将内存划分为4个区域： 
**代码区：**存放函数体的二进制代码，由操作系统进行管理的 
**全局区：**存放全局变量和静态变量以及常量 
**栈区：**由编译器自动分配释放, 存放函数的参数值,局部变量等 
**堆区：**由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收 

#### 1.1 运行前：

在程序编译后，生成了exe可执行程序，未执行该程序前存在**代码区**和**全局区** 。 
**代码区：** 
其中代码区存放了CPU执行的机器指令。代码区拥有**共享**（内存中只需要有一份代码）和**只读**（不可以被修改）两个特点。 
**全局区：** 
全局区存放了**全局变量**和**静态常量**和**常量**。该区域的数据在程序结束后由操作系统释放。 
**注意事项：** 
1、只要在函数中定义的变量（包括const修饰的局部变量）都是**局部变量**，保存在**栈**中，与常量区的内容存储区域不同；
2、在变量前有`static`属于**静态变量**；
3、在函数外定义的变量称为**全局变量** ；
4、**常量** 包括**字符串常量**和**const修饰的全局变量** 。

#### 1.2 运行后：
**栈区：**
由编译器自动分配释放，存放函数的参数值（形参），局部变量等。注意不能返回局部变量的地址，因为局部变量存放在栈区，在函数执行完后会自动释放。 
**堆区：**
由程序员开辟和释放，若程序不释放，程序结束后由操作系统自动回收。C++中利用new开辟内存。

#### 1.3 new操作符的使用：
语法：`数据类型 *a = new 数据类型<与前相同>（数据）`
注意new返回的是该数据对应的类型的地址，所以需要用一个指针来接收它。
如在函数中定义`int* p = new int(10);`实际上指针p属于局部变量且保存在栈中，但由p指向的数据保存在堆区。 

---

## 2、引用 

语法：`数据类型 &别名 = 原名` 
此时别名称为原名的引用
**注意事项：** 
1、引用必须进行初始化: `int &b = a`，并且不能分成两步：`int &b` + `b = a`； 
2、引用一旦初始化，就不能被修改；
3、引用必须引用合法的内存空间（不能是常量）。

#### 2.1 引用做函数参数： 

函数的参数传递包括：**值传递、地址传递、引用传递** 

**值传递：**
当信息被传递给一个函数时，采用按值传递的方式，这意味着**形参接收的是传递给它的值的副本**。如果形参的值在函数内部被改变，那么它对原始实参是没有影响的。这说明：**形参变量在内存中的存储位置与原始实参的存储位置是分开的。**  

**地址传递：**
使用数组名或者指针作为函数参数，传递的是该数组的首地址或指针的值，而形参接收到的是地址。编译系统不为形参数组分配内存，因此在数组名或指针作函数参数时所进行的传送只是地址传送，形参在取得该首地址之后，与实参共同拥有一段内存空间，形参的变化也就是实参的变化。

**引用传递：**
引用变量： `int &b =a`   引用数组： `int (&b)[sizeof(a)/sizeof(a[0])] = a` 
令b是a的引用，该操作实际上是让a和b都指向同一片内存单元。 
引用变量是变量的另一个别名，它没有自己的存储数据的内存位置，它访问的是另一个变量的内存地址。 
当使用引用变量作为形参时，它将变为实参列表中相应变量的别名，对形参进行的任何更改都将真正更改正在调用它的函数中的变量。 （引用传递）

**区别：**
值传递（pass-by-value）：值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间来存放由主调函数放进来的**实参的值**，从而成为了**实参的一个副本**。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值；
引用传递（pass-by-reference）：在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但这时存放的是**由主调函数放进来的实参变量的地址**。被调函数对形参的任何操作都被处理成**间接寻址**，即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做任何的操作都影响了主调函数中的实参变量；

注意事项：
1、引用必须声明时就要有初始化，如`int &b`会报错 
2、引用初始化的变量一定要能取地址，如`int &a = 10`10是常量不能被引用，除非用const组成常引用:`const int &a = 10` 
3、引用不可中途改变 

#### 2.2 引用做函数返回值： 

**注意事项：**
1、不能返回局部变量的引用。因为局部变量会被释放，引用变量只能使用一次（编译器记录），之后为乱码； 
2、如果函数值的返回值是引用，则函数的调用可以作为左值。

#### 2.3 引用本质： 
引用的本质是在c++内部实现一个**指针常量**用以表现变量的别名这一特性：
当遇到 `int& ref = a` 编译器会自动转换为 `int* const ref = &a`，即**将引用ref设置为一个指针常量并指向被引用的变量，保存该变量的地址，且指针的指向不可以被修改** 
遇到 `ref = 20`时，编译器自动转换为`*ref = 20`，即**将出现的引用ref自动解引用，并获取被引用变量地址所存放的值**  

#### 2.4 常量引用：
作用：常量引用通过const修饰形参，防止形参改变实参
**语法：const 引用类型& 引用 = 常量**
如，`const int& ref = 10;` 编译器自动修改为 `int temp = 10; int& ref =temp;`



## 3、函数提高

#### 3.1 默认参数
**注意事项：** 
1、如果某个位置已经有了默认参数，则这个位置往后都必须有默认参数 
2、如果函数声明和实现其中只有一个能有默认参数 

#### 3.2 占位参数 
**语法： 返回值类型 函数名（数据类型）{}** 
**注意事项：** 
1、占位参数可以有默认参数 
2、主要用于函数重载

#### 3.3 函数重载
**作用：** 
函数名可以相同，提高复用性 
**条件：** 
（1）必须在同一个作用域下（都在全局作用域或同一类）； 
（2）函数名相同； 
（3）函数参数类型不同，或者个数不同，或者顺序不同。 
**注意事项：** 
1、（重要）函数值的返回不可以作为函数重载的条件； 
2、引用作为函数重载的条件（形参分别是引用和常量引用）满足函数重载条件； 
3、函数重载遇到默认参数，如果调用函数出现二义性，则会报错。



---



## 4、类和对象

C++面向对象的三大特性：**封装、继承、多态** 
C++认为：万事万物都是对象，对象上有其属性和行为 
具有相同性质的对象，我们可以抽象为**类** 

#### 4.1 封装 
**语法：class 类名{ 访问权限1：属性/行为 访问权限2：...}** 
在设计类时，属性和行为写在一起： 
（1）类中的属性和行为，我们统一称为**成员** 
（2）类中的属性：成员属性/成员变量 
（3）类中的行为：成员函数/成员方法  

**访问权限：** 
**公共权限(public)、保护权限(protected)、私有权限(private)** 

**注意事项：** 
1、三种访问权限的区别： 
公共权限：类内和类外都可以访问 
保护权限和私有权限：类内可以访问，类外不可以访问。子类可以继承保护权限的内容，但不可以继承私有权限的内容； 
2、struct和class两者类似，但默认的访问权限不同，struct中默认为公共，class默认为私有； 
3、我们通常将成员属性设置为私有，首先可以自己控制读写的权限（添加一些public的读写接口），其次对于写权限，我们可以检测数据的有效性； 
4、我们可以先声明一个类，在之后再进行定义。 

##### 案例：立方体类  
**Note:** 
判断两个立方体是否相等，有两种方式：全局函数和成员函数 
全局函数的方法利用引用传递分别传入两个立方体(&c1,&c2)，再对这两个立方体的属性进行判断。
成员函数的方法只需引用传递一个立方体(&c)，对这个立方体的属性和该成员函数所在的实例的属性(利用get获取)进行判断。

##### 案例：点和圆类
**注意事项：** 
1、在类中可以让另一个类作为本类中的成员 
2、可以将一个类拆成两部分，将类的定义，包括类的权限、类的函数声明、类的属性写在头文件中；再将各方法以"全局函数"的形式写在源文件中，在函数前加 **类名::** 表示该方法作用域在该类中。 
点类的头文件(注意圆类的头文件出现Point，需要再包含点类的头文件表示该类存在)

```C++
#pragma once
class Point {
private:
	int m_x;
	int m_y;
public:
	void set_x(int x);
	void set_y(int y);
	int get_x();
	int get_y();
};
```
点类的源文件（注意要包含点类的头文件）
```C++
#include "point.h"
#include <iostream>
using namespace std;

void Point::set_x(int x) {
	m_x = x;
}
void Point::set_y(int y) {
	m_y = y;
}
int Point::get_x() {
	return m_x;
}
int Point::get_y() {
	return m_y;
}
```

#### 4.2 对象的初始化和清理
#### 4.2.1 构造函数和析构函数 

构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 
析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。
c++利用了构造函数和析构函数完成对象初始化和清理工作，这两个函数将会被编译器自动调用。 
对象的初始化和清理工作是编译器强制要做的事情，因此如果我们不提供构造和析构，编译器会自动提供。编译器提供的构造函数和析构函数是空实现。

**构造函数：** 
构造函数语法：`类名(){} ` 
**注意事项：** 
1、构造函数，没有返回值也不写void 
2、函数名称与类名相同
3、构造函数可以有参数，因此可以发生重载 
4、程序在**调用对象**时候会自动调用构造，无须手动调用,而且只会调用一次 

**析构函数：**
析构函数语法：`~类名(){ }`
一般当构造函数中出现new创建在堆上的内存，需要在析构函数中利用delete手动释放空间。其余情况，可以使用默认析构函数。
**注意事项：** 
1、析构函数，没有返回值也不写void 
2、函数名称与类名相同，只需要在名称前加上符号 ~ 
3、析构函数不可以有参数，因此不可以发生重载 
4、程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次 

#### 4.2.2 构造函数的分类和调用

##### 分类：
按参数分：无参构造（默认构造） 有参构造 
按类型分：普通构造 拷贝构造

##### 调用方法：

**1、括号法：**

```C++
Test t1;//调用默认构造函数
Test t1();//error，编译器认定为声明
Test t2(10);//调用参数构造函数
Test t3(t2);//调用拷贝构造函数
```
调用默认构造函数时，不要加()，如Test t1()，编译器会认为这是一个函数的声明。 

**2、显示调用法：**

```C++
Test t1 = Test();//默认构造
Test t2 = Test(10);//有参构造，我们称Test(10)为匿名对象，当前行执行结束后，系统会立刻回收该对象 
Test t3 = Test(t2);//拷贝构造
```
不要利用拷贝构造函数初始化匿名对象，如Test(t3)，编译器会认为这是一个对象的声明。

**3、隐式转换法（编译器自动转换为显式法）：**
```C++
Test t4 = 10;//相当于Test t4 = Test(10) 有参构造
Test t5 = t4;//相当于Test t5 = Test(t4) 拷贝构造
```

#### 4.2.3 拷贝构造函数：

#### 调用情况： 

拷贝构造函数语法：`类名(const 类名& 被拷贝的对象){} ` 
构造函数的调用：`类名 拷贝对象(被拷贝的对象)` 

**1、使用一个已经创建完毕的对象来初始化一个新对象（常用）**  

```C++
	Test a;
	Test b(a);
```
**2、值传递的方式给函数参数传值** 

```C++
void doWork1(Test t){}//值传递，创建一个Test类的副本t，如果在函数内改变t的属性，不会改变test1中的t
void test1() {
	Test t;
	doWork1(t);
}
```
**3、以值方式返回局部对象** 

```C++
Test doWork2() {
	Test t;
	cout << "doWork中的t地址为" << (int*)&t << endl;//此处t的地址是利用默认构造函数创建的t的地址
	return t;
}
//先调用拷贝构造函数创建一个t的副本用作值方式返回，之后自动调用析构函数依次释放该副本和doWork2中的t
void test2() {
	Test t = doWork2();//将返回值赋值给t时调用拷贝构造
	cout << "test2中的t地址为"<<(int*)&t << endl;//此处t的地址为利用拷贝构造函数创建t副本的地址
}
```

##### 注意事项：

1、拷贝构造函数的参数类型是本类的引用，一般可以是const引用也可以是非const引用，通常使用前者，这样既能以常量对象（初始化后值不能改变的对象）作为参数，也能以非常量对象作为参数去初始化其他对象;
2、默认的无参构造函数不一定存在，但拷贝构造函数一定存在；

#### 4.2.4 构造函数的调用规则：

默认情况下，c++编译器至少给一个类添加3个函数 
1．默认构造函数（无参，函数体为空） 
2．默认析构函数（无参，函数体为空） 
3．默认拷贝构造函数，对(所有)属性进行值拷贝 

**注意事项：**  
1、如果用户定义有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造;
2、如果用户定义拷贝构造函数，c++不会再提供其他构造函数;
3、可以先声明一个构造函数，在类外再进行实现（添加构造函数的作用域）。

#### 4.2.5 深拷贝和浅拷贝：
浅拷贝：简单的赋值拷贝操作（默认拷贝构造函数是浅拷贝） 
深拷贝：在堆区重新申请空间，进行拷贝操作 
**注意事项：** 
1、如果利用编译器提供的拷贝构造函数，会做浅拷贝操作，浅拷贝的问题在于析构函数对于堆区的内存会**重复释放** ；
2、为防止堆区重复释放，要自己编写拷贝构造函数实现**深拷贝**；  
3、当遇到堆区开辟内存时，析构函数需要对开辟的内存进行释放。

#### 4.2.6 利用初始化列表初始化属性：
用于给非静态成员变量初始化 
语法：`Constructor()：arribute1(value1),attribute2(value2)...{...}` 

```C++
//将类成员变量分别用a,b,c来赋值
Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}
```
**注意事项：** 
1、使用初始化列表初始化属性又称为显式初始化； 
2、C++ 初始化类成员时，是按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序； 
3、必须用带有初始化列表的构造函数的情形： 
(1)成员类型是没有默认构造函数的类。若没有提供显式初始化式，则编译器隐式使用成员类型的默认构造函数，若类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。 
(2)const 成员或引用类型的成员。因为 const 对象或引用类型只能初始化，不能对他们赋值。 

#### 4.2.7 类对象作为类成员： 
**注意事项：** 
当其他类的对象作为本类的成员： 
1、在构造本类的对象会先构造其他类的对象，再构造自身； 
2、析构函数先释放自身的构造函数，再释放其它类的对象（后构造先析构，先构造后析构）
3、定义类对象时，编译器直接为其分配内存；但若用其他类的指针作为本类的成员，编译器不为其分配内存，只有在构造函数中用new初始化后才分配，且为内存堆；

#### 4.2.8 静态成员:
静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员 
静态成员分为：静态成员变量和静态成员函数

##### 静态成员变量:  
静态成员变量有两种访问方式：通过对象访问`p.a`、通过类名访问`Person::a` 
**注意事项：**
1、静态成员变量不属于某个对象，所有对象共享同一份数据 
2、在编译阶段分配内存 (静态成员变量位于全局区) 
3、类内声明:`static int atrribute`，类外初始化:`int ClassName::attribute = value` 
4、类外访问不到私有静态成员变量  

##### 静态成员函数：
静态成员函数有两种访问方式：通过对象访问`p.func()`、通过类名访问`Person::func()`  
**注意事项：** 
1、所有对象共享同一个函数 
2、静态成员函数只能访问静态成员变量，而不可以访问非静态成员变量 
4、类外访问不到私有静态成员函数  

#### 4.2.9 类指针：
类指针是一个内存地址值，它指向内存中存放的类对象  
**注意事项：** 
1、只有执行new后才会分配内存，且为内存堆。 
2、访问指向类的指针的成员，需要使用成员访问运算符->；  
3、在使用指针之前，必须用new对指针进行初始化:Test* t1 = new Test()。  

**类指针和类对象的区别：** 
作用基本一样 用途都是为了调用类的成员变量和成员函数； 
当希望明确使用这个类的时候，最好使用对象；  
如果希望使用C++中的动态绑定，则最好使用指针或者引用，指针和引用用起来更灵活，容易实现多态等。 



### 4.3 C++对象模型和this指针
#### 4.3.1 成员变量和成员函数分开存储
C++中类内的成员变量和成员函数分开存储 
**注意事项：** 
1、非静态成员变量占对象空间，静态成员变量不占对象空间； 
2、空对象占用内存空间为1个字节，C++编译器会给每个空对象分配一个字节的空间，用于区分空对象占内存的位置；每个空对象应该有一个独一的内存地址； 

#### 4.3.2 this指针
由于每一个非静态成员函数只会产生一份函数实例，多个同类型的对象会共用同一块代码，this指针用于区分是哪个对象调用了自己。**this指针指向 被调用的成员函数 所属的对象** 

**使用场景：** 
1、当形参和成员变量同名时，为解决名称冲突， 可以用this指针区分； 
2、在类的非静态成员函数中返回对象本身，可使用return *this

**注意事项：** 
1、this指针是隐含每一个非静态成员函数中的一种指针； 
2、this指针不需要定义，直接使用即可；
3、当我们使用类成员变量时，编译器自动会在变量前加上this-> 
4、this指针的本质是一个指针常量:`类名* const this`，指针的指向不可以被修改

#### 4.3.3 空指针访问成员函数 
在C++的类中，当我们使用类成员变量时，编译器自动会在变量前加上this->，因此如果对象所指向的地址为NULL，会报错而无法访问类的成员函数 
添加：`if(this == NULL) return; `可以增强代码的健壮性。 

#### 4.3.4 const修饰成员函数
##### 常函数
成员函数后加const后我们称为这个函数为常函数；
语法：`函数返回值类型 函数名() const` 
const是在修饰this指针，表示this指针既不可以修改指针的指向，又不可以修改指针指向的值 
**注意事项：** 
1、常函数内不可以修改成员属性（this指向的值）； 
2、成员属性声明时加关键字mutable后，在常函数中依然可以修改。 

##### 常对象
声明对象前加const称该对象为常对象 
语法：`const 类名 对象名` 
**注意事项：** 
1、常对象只能调用常函数;
2、成员属性声明时加关键字mutable后，在常对象中依然可以修改。

### 4.4 友元
友元的目的就是让一个函数或者类访问另一个类中私有成员。 
友元函数可以让本不属于该类的成员函数有权利访问这个类的私有成员或是保护成员。
友元的三种实现：全局函数做友元、类做友元、成员函数做友元 
**注意事项：** 
1、**定义**在类中的友元函数,其作用域在全局作用域下，没有在类中的友元声明之前声明的友元函数,其作用域则在第一个包围类的非类作用域下；
2、友元类应该在拥有私有属性且允许被外界访问的那个类中进行声明，意思就是让别的类来访问自己的私有成员。

**全局函数做友元:**

```C++
friend void goodguy(Building* building);
```
**类做友元:**

谁的私有成员需要被访问，就把访问者的类名写在该类中作为友元。

```C++
//GoodGay是本类的友类，可以访问Building类的私有内容
friend class GoodGay;
```
**成员函数做友元:**

一定要加成员函数的作用域

```C++
friend void goodGay::visit();
```

### 4.5 运算符重载
对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 
格式： 

```C++
类名 operator 要重载的运算符()；//函数声明 
类名 operator 要重载的运算符() //函数主体  
{ 
  //具体操作 
}
```

**注意事项：** 
1、若使用全局函数重载运算符，则一般在类中声明该运算符重载函数是友元函数；
2、采用全局函数能使我们定义这样的运算符的参数具有逻辑的**对称性** ； 
3、把运算符定义为成员函数能够保证在调用时对第一个（最左的）运算对象不出现类型转换，也就是**C++ 不会对调用成员函数的对象进行类型转换** ； 
4、有一部分运算符重载既可以是成员函数也可以是全局函数，虽然没有一个必然的、不可抗拒的理由选择成员函数，但我们应该优先考虑成员函数，这样更符合运算符重载的初衷； 
5、C++ 规定，箭头运算符->、下标运算符[]、函数调用运算符()、赋值运算符=只能以成员函数的形式重载。


#### 4.5.1 加号运算符重载
作用：实现两个自定义数据类型相加的运算。 
```
Person operator+(Person& p) {...}//成员函数重载+号
Person operator+(Person& p1,Person& p2) {...}//全局函数重载+号
Person operator+(Person& p, int a){...}//运算符重载 可以发生函数重载
```
**注意事项：** 
1、成员函数重载的本质：`Person p3 = p1.operator+(p2); `
2、全局函数重载的本质：`Person p3 = operator+(p1, p2); `
3、运算符重载可以发生函数重载；
4、最好要以全局函数的形式重载+，这是为了保证+运算符的操作数能够被对称的处理：也就是说在+左边和右边都是正确的，比如用成员函数重载+后，写1+a，则(1).operator+(a)会报错

#### 4.5.2 左移运算符重载
作用：可以输出自定义数据类型。 

```C++
ostream& operator<<(ostream &cout, Person &p) {//本质：operator<<(cout, p) 简化：cout<<p
  cout << "m_A = " << p.m_A << " m_B = " << p.m_B;
	return cout;
}
```
**注意事项：**
1、cout为ostream类型，标准输出流对象；
2、由于输出流对象cout全局只能有一个（iostream的拷贝构造函数不允许使用）因此在重载左移运算符时必须用引用传递cout；
3、为了满足链式编程，需要使重载函数返回cout，这样才能实现连续的<<；
4、重载运算函数的形参顺序不可改变，因为其对应着编译器简化后的运算关系； 
5、成员函数重载<<运算符，无法实现cout在左侧，因此只能利用全局函数重载左移运算符。

#### 4.5.3 递增运算符重载
作用：通过重载递增运算符，实现自己的整型数据。 

**重载前置递增：**

```C++
MyInteger& operator++() {//先++后返回
		m_Num++;
		return *this;//返回对象本身，这样多次++可以对同一个对象进行
	}
```

**重载后置递增：** 

```C++
	MyInteger operator++(int) {//先返回后++
		MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值
		m_Num++;
		return temp;
	}
```

**return this和return *this的区别：** 
1、this是指向自身对象的指针，*this是自身对象； 
2、return *this返回的是当前对象的克隆或者本身（若返回类型为值类型，则是克隆；若返回类型为引用类型，则是本身）；return this返回当前对象的地址（指向当前对象的指针）。

**注意事项：** 
1、由于编译器必须能够识别出前置与后置运算符，人为规定用`operator++()`和`operator–-()`重载前置运算符，用`operator++(int)`和`operator–-(int)`重载后置运算符;  

2、前置递增必须返回的是类的引用，这是因为如果返回类的值，则++(++a)虽然打印的是正确的结果，但对a实际上只做了一次前置递增，由于第一次++之后返回的是一个新的对象，第二次递增是对新对象进行的；因此返回引用是为了对一个数据进行递增；  

3、后置递增必须返回的是类的值，因为重载函数中返回的是局部变量，局部变量在函数运行结束后即释放，不能返回它的引用； 

4、在做后置递增运算符重载时，左移运算符重载传入的类对象必须要以值传递的方式传入，这是因为在后置递增时，返回的是一个局部变量，用值方式才能接受一个局部变量； 

#### 4.5.4 赋值运算符重载
赋值运算符operator=是C++编译器自动添加的函数，其作用是为属性进行值拷贝。 
但当我们进行浅拷贝(p2=p1)时，利用析构函数释放堆区数据会发生重复释放问题。因此需要进行赋值运算符重载。
```C++
Person& operator=(Person& p) {
		//编译器提供浅拷贝：m_Age = p.m_Age;
		if (m_Age != NULL) {//如果需要拷贝的对象存在堆区数据，则清空
			delete m_Age;
			m_Age = NULL;
		}
		m_Age = new int(*p.m_Age);//重新在堆区开辟一个区域，值与p.m_Age相同
		return *this;//以引用形式返回对象本身 
	}
```
**注意事项：** 
1、赋值运算符重载的本质：`a.operator=(b)` => a = b 
2、最终将函数返回对象本身，且以引用形式返回是为了实现a=b=c的链式结构； 

#### 4.5.5关系运算符重载
重载关系运算符，可以让两个自定义类型对象进行对比操作
```C++
bool operator==(Person & p){
	if (this->m_Name == p.m_Name && this->m_Age == p.m_Age){
		return true;
	}
	else{
		return false;
	}
}
```

#### 4.5.6 函数调用运算符重载
函数调用运算符 () 可以重载，又称为仿函数 

### 4.6 继承
#### 4.6.1 基本语法
继承允许我们依据另一个类来定义一个类,这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。 
这个已有的类称为基类（父类），新建的类称为派生类（子类）。 

继承的语法：`class derived-class: access-specifier base-class`

#### 4.6.2 继承方式 
继承方式包括：公有继承(private)、保护继承(protected)、私有继承(private) 

1、父类为private，则子类任何一种继承方式都不可以访问； 
2、公有继承：父类是公共/保护，子类相同； 
3、保护继承：父类是公共/保护，子类均变为保护； 
4、私有继承：父类是公共/保护，子类均变为私有。

#### 4.6.3 继承中的对象模型
父类中所有非静态成员属性都会被子类继承，包括私有成员属性在内，只是被编译器隐藏了。

查看C++类的内存分布：`cl /d1 reportSingleClass类名 文件名`  

#### 4.6.4 继承中构造和析构的顺序
构造顺序：父类构造->子类构造
析构顺序：子类析构->父类析构

#### 4.6.5 继承同名成员处理方式
背景：s是Son类的一个实例，Son类继承自Base类且两者都有m_A和func()成员，Base类存在func(int a)的函数重载

```C++
#include <iostream>
using namespace std;

class Base {
public:
	int m_A = 200;
	static int m_B;
};
int Base::m_B = 200;

class Son :public Base
{
public:
	int m_A = 100;
	static int m_B;
};
int Son::m_B = 100;

void test01() {
	Son s;
	cout << s.m_A << endl;
	cout << s.Base::m_A << endl;
}

void test02() {
	Son s;
	//通过对象访问
	cout << "通过对象访问" << endl;
	cout << s.m_B << endl;
	cout << s.Base::m_B << endl;
	//通过类名访问
	cout << "通过类名访问" << endl;
	cout << Son::m_B << endl;
	cout << Son::Base::m_B << endl;
}

int main() {
	//test01();
	test02();

	system("pause");
	return 0;
}
```



同名成员属性和函数的处理： 
1、子类对象可以直接访问到子类中同名成员:`s.m_A` `s.func()` 
2、子类对象加作用域可以访问到父类同名成员：`s.Base::m_A` `s.Base::func()`  

**注意事项：** 
当子类与父类拥有同名的成员，子类会隐藏父类中所有版本（重载）的同名成员，需要加父类的作用域访问父类中被隐藏的同名成员：`s.Base::func(10)`，即调用父类的所有同名成员必须加作用域。


#### 4.6.6 继承同名静态成员处理方式
静态成员和非静态成员出现同名，处理方式基本一致 
静态成员的访问有两种方法：通过对象访问、通过类名访问 
具体如下（静态成员函数同）： 
对象访问：`s.m_A` `s.Base::m_A` 
类名访问：`s::m_A` `Son::Base::m_A`（第一个::指通过类名方式访问，第二个::指在Base作用域下的属性

#### 4.6.7 多继承
语法：`class subclass: 继承方式 superclass1, 继承方式 superclass2` 
多继承可能会引发父类中有同名成员出现，需要加作用域区分

#### 4.6.8 菱形继承
菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义；利用虚继承可以解决菱形继承问题 
虚继承底层的实现：两个类的继承不再继承数据而是继承2个指针，指针通过相应的偏移量找到唯一一个数据 

### 4.7 多态
#### 4.7.1 多态的基本概念
多态分为两类： 
**静态多态：函数重载**和**运算符重载**属于静态多态，复用函数名 
**动态多态：**派生类和虚函数运行时多态(c++所指的多态大多是动态多态)

**静态动态和动态多态的区别：**
静态动态（函数地址早绑定）在编译阶段确定函数地址
动态多态（函数地址晚绑定）在运行阶段确定函数地址  

**动态多态满足的条件：** 
1、有继承关系 2、子类**重写**父类的虚函数(父类必须带virtual，子类可带可不带)

**动态多态的使用：**
当**父类的指针或者引用指向子类的对象**时，发生多态

**注意事项：** 
1、C++自动实现父类和子类之间的类型转换，不需要强制类型转换
2、重写指重新写的函数与原函数**返回值类型**、**函数名**、**参数列表**完全相同
**3、（重要）**当发生动态多态时，运行期间自动为父类添加一个指针vfptr[虚函数（表）指针]，大小占四个字节，该指针指向vftable[虚函数表]，在表的内部记录着虚函数的地址 （&Animal::speak)，子类中也会继承这个指针（大小不变）； 当子类重写父类的虚函数时，子类的虚函数表的内部会被替换成子类的虚函数地址，变为(&Cat::speak) 

#### **4.7.2 计算机类实例**
实际开发中提倡开闭原则：**对扩展进行开放，对修改进行关闭**
多态的优点： 
1、组织结构清晰（抽象类+实现类），各司其职，哪里有问题改哪里 
2、可读性强 
3、对前期和后期的可扩展性以及可维护性好，不用对源代码进行修改，只需追加 

```C++
//实现计算器抽象类
class AbstractCaculator {
public:
	int m_Num1;
	int m_Num2;
	virtual int getResult() {
		return 0;
	}
};
//加法计算器类
class AddCaculator :public AbstractCaculator {
public:
	int getResult() {
		return m_Num1 + m_Num2;
	}
};
//测试实例
void test01() {
	AbstractCaculator* abc = new AddCaculator;
	abc->m_Num1 = 10;
	abc->m_Num2 = 10;
	cout << abc->m_Num1 << " + " << abc->m_Num2 << " = " << abc->getResult() << endl;
	delete abc;
}
```

#### 4.7.3 纯虚函数和抽象类
纯虚函数语法：`virtual 返回值类型 函数名（参数列表） = 0;`（=0是说明符） 
只要类中有一个纯虚函数，就称这个类为抽象类  

**注意事项：** 
1、抽象类无法实例化对象;
2、抽象类只能作为父类，其子类必须重写抽象类的（全部）纯虚函数，否则无法实例化对象，也将成为抽象类； 
3、虽然抽象类无法实例化，但可以通过引用或指针指向子类对象的方法访问虚函数； 
4、子类重写的虚函数最好也写上virtual（虽然加不加功能一样），这样表示更清晰，能一眼看出是对父类纯虚函数的重写，可读性强。

e.g.[C++纯虚函数和抽象类详解 (biancheng.net)](http://c.biancheng.net/view/2299.html)

```C++
#include <iostream>
using namespace std;
//线
class Line{//纯虚函数一般作为基类
public:
    Line(float len);
    virtual float area() = 0;
    virtual float volume() = 0;
protected://保护权限的成员可以被继承
    float m_len;
};
Line::Line(float len): m_len(len){ }//使用初始化列表进行函数构造

//矩形
class Rec: public Line{//公有继承，成员权限继承前后一致
public:
    Rec(float len, float width);
    float area();//只实现了一个虚函数，依旧是抽象类
protected:
    float m_width;
};
Rec::Rec(float len, float width): Line(len), m_width(width){ }
float Rec::area(){ return m_len * m_width; }

//长方体
class Cuboid: public Rec{//实现所有虚函数，此时该类才可以被实例化
public:
    Cuboid(float len, float width, float height);
    float area();
    float volume();
protected:
    float m_height;
};
Cuboid::Cuboid(float len, float width, float height): Rec(len, width), m_height(height){ }//用类初始化类
float Cuboid::area(){ return 2 * ( m_len*m_width + m_len*m_height + m_width*m_height); }
float Cuboid::volume(){ return m_len * m_width * m_height; }

//正方体
class Cube: public Cuboid{//实现所有虚函数，此时该类才可以被实例化
public:
    Cube(float len);
    float area();
    float volume();
};
Cube::Cube(float len): Cuboid(len, len, len){ }
float Cube::area(){ return 6 * m_len * m_len; }
float Cube::volume(){ return m_len * m_len * m_len; }
int main(){
    Line *p = new Cuboid(10, 20, 30);
    cout<<"The area of Cuboid is "<<p->area()<<endl;
    cout<<"The volume of Cuboid is "<<p->volume()<<endl;
  
    p = new Cube(15);
    cout<<"The area of Cube is "<<p->area()<<endl;
    cout<<"The volume of Cube is "<<p->volume()<<endl;
    return 0;
}
```



#### 4.7.4 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码

解决方式：将父类中的析构函数改为**虚析构**或者**纯虚析构**

虚析构和纯虚析构共性：

- 可以解决父类指针释放子类对象
- 都需要有具体的函数实现

虚析构和纯虚析构区别：

- 如果是纯虚析构，该类属于抽象类，无法实例化对象

**注意事项：**

1、虚析构或纯虚析构主要用来解决**通过父类指针释放子类对象**
2、如果子类中没有堆区数据，可以不写为虚析构或纯虚析构
3、拥有纯虚析构函数的类也属于抽象类

e.g.(虚析构)

```C++
class Animal {
public:
	Animal() {
		cout << "Animal构造函数调用" << endl;
	}
	virtual ~Animal() {
		cout << "Animal析构函数调用" << endl;
	}
	virtual void speak() = 0;
};

class Cat :public Animal {
public:
	Cat(string n) {
		cout << "Cat构造函数调用" << endl;
		name = new string(n);
	}
	~Cat() {
		if (name != NULL) {
			cout << "Cat析构函数调用" << endl;
			delete name;
			name = NULL;
		}
	}
	virtual void speak() {
		cout << *name << "小猫在说话" << endl;
	}
	string* name;
};

void test01() {
	Animal* animal = new Cat("Tom");//父类指针指向子类对象
	animal->speak();
	delete animal;//父类指针析构时不会调用子类的析构函数，导致子类会出现内存泄漏。解决方法->将父类的析构函数改为虚析构
}
```

e.g.(纯虚析构)

```C++
class Animal {
public:
	Animal() {
		cout << "Animal构造函数调用" << endl;
	}
	virtual ~Animal() = 0;
	virtual void speak() = 0;
};
Animal::~Animal() {
	cout << "Animal的纯虚析构函数" << endl;
}
```

#### 4.7.5 多态实现组装电脑实例

```C++
#include <iostream>
#include <string>
using namespace std;

class CPU {//CPU抽象类
public:
	virtual void caculate() = 0;
};

class GPU {//GPU抽象类
public:
	virtual void display() = 0;
};

class Memory {//Memory抽象类
public:
	virtual void storage() = 0;
};

class Computer {
public:
	Computer(CPU* c, GPU* g, Memory* m) {
		cpu = c;
		gpu = g;
		memory = m;
	}

	void work() {
		cpu->caculate();
		gpu->display();
		memory->storage();
	}
	~Computer() {
		if (cpu != NULL) {
			delete cpu;
			cpu = NULL;
		}		
		if (gpu != NULL) {
			delete gpu;
			gpu = NULL;
		}		
		if (memory != NULL) {
			delete memory;
			memory = NULL;
		}
	}
private:
	CPU* cpu;
	GPU* gpu;
	Memory* memory;
};

class IntelCPU :public CPU {
public:
	virtual void caculate() {
		cout << "Intel的CPU工作" << endl;
	}
};

class IntelGPU :public GPU {
public:
	virtual void display() {
		cout << "Intel的GPU显示" << endl;
	}
};

class IntelMemory :public Memory {
public:
	virtual void storage() {
		cout << "Intel的内存条存储" << endl;
	}
};

class LenovoCPU :public CPU {
public:
	virtual void caculate() {
		cout << "Lenovo的CPU工作" << endl;
	}
};

class LenovoGPU :public GPU {
public:
	virtual void display() {
		cout << "Lenovo的GPU显示" << endl;
	}
};

class LenovoMemory :public Memory {
public:
	virtual void storage() {
		cout << "Lenovo的内存条存储" << endl;
	}
};

void test01() {
	CPU* intelCpu = new IntelCPU;
	GPU* intelGpu = new IntelGPU;
	Memory* intelMemory = new IntelMemory;
	//组装地一台电脑
	cout << "第一台电脑开始工作！" << endl;
	Computer* computer1 = new Computer(intelCpu, intelGpu, intelMemory);
	computer1->work();
	delete computer1;	
	cout << "---------------" << endl;
	cout << "第二台电脑开始工作！" << endl;
	Computer* computer2 = new Computer(new LenovoCPU, new LenovoGPU, new LenovoMemory);
	computer2->work();
	delete computer2;
	cout << "---------------" << endl;
	cout << "第三台电脑开始工作！" << endl;
	Computer* computer3 = new Computer(new IntelCPU, new LenovoGPU, new IntelMemory);
	computer3->work();
	delete computer3;
}
```



## 5、文件操作

文件类型包括：文本文件（以文本的ASCII码存储）和二进制文件（以文本的二进制形式存储）

头文件：`#include <fstream>`

操作文件的三种类型：(1)ofstream 写操作  (2) ifstream 读操作  (3)fstream 读写操作

### 5.1 文本文件

#### 5.1.1 写文件

**注意事项：**
1、操作完毕，要关闭文件；
2、使用ofstream或fstream创建流对象均可，但在写操作时，fstream(path,mode)的mode必须指定ios::out，而ofstream可以省略。

方法一：

```C++
ofstream ofs;//创建流对象
ofs.open("path",ios::out);
ofs<<"sth"<<endl;//写入一行
ofs.close();
```

方法二：

```C++
ofstream ofs("path");//ofstream省略Mode时默认为ios::out
ofs<<"sth"<<endl;//写入一行
ofs.close();
```



#### 5.1.2 读文件

全局函数，函数声明为：

`ifstream& getline ( istream& is, string& str, char delim)`

`ifstream& getline ( istream& is, string& str)`

ifstream的成员函数，函数声明为：

`ifstream& getline (char* s, streamsize n)`

`ifstream& getline (char* s, streamsize n, char delim) `

**注意事项：**
1、delim为每次读的结束符，默认为"\n"，可以按要求修改；
2、fstream也可以进行读操作，但要指定mode为ios::in。
3、全局函数要求buf为string类型，成员函数要求buf为const char*类

读文件的四种方式：

方法一：

```C++
char buf[1024]={0};
while(ifs>>buf){
    cout<<buf<<endl;
}
```

方法二：

```C++
char buf[1024]={0};
while(ifs.getline(buf,sizeof(buf),"\n")){//readline的第三个参数如果省略则默认为"\n"，可以按要求指定
	cout<<buf<<endl;
}
```

方法三：

```C++
string buf;
while(getline(ifs,buf,"\n")){
    cout<<buf<<endl;
}
```

方法四（效率较低）:

```C++
char c;
while((c = ifs.get()!=EOF){//EOF=end of file
	cout<<c;
}
```



### 5.2 二进制文件

以二进制的方式对文件进行读写操作，打开方式指定为ios::binary

#### 5.2.1 写文件

二进制方式写文件主要利用流对象调用成员函数write

函数原型 ：`ofstream& write(const char * buffer,int len);` 字符指针buffer指向内存中一段存储空间。len是读写的字节数。

**注意事项：**
1、如果需要一个对象，则buffer位置应该读入对象的地址，再强制类型转换，如下所示。

e.g.

```C++
class Person {
public:
	Person() {}
	Person(const char* name, int age) {
		this->age = age;
		strcpy_s(this->name, name);
	}
	const char* get_name() {
		return this->name;
	}
	int get_age() {
		return this->age;
	}
private:
	char name[64];
	int age;
};

void test01(){
    ofstream ofs("person.txt", ios::out | ios::binary);
    Person p("张三", 18);
    ofs.write((const char*)&p,sizeof(p));
    ofs.close();
}
```



#### 5.2.2 读文件

二进制方式读文件主要利用流对象调用成员函数read

函数原型：`istream& read(char *buffer,int len);` 字符指针buffer指向内存中一段存储空间。len是读写的字节数。

e.g.

```C++
void test02(){	
	ifstream ifs("./person.txt", ios::in | ios::binary);
	if (!ifs) {
		cout << "文件打开失败！" << endl;
		return;
	}
	Person p1;
	ifs.read((char*)&p1, sizeof(p1));
	cout << "姓名：" << p1.get_name() << " 年龄：" << p1.get_age() << endl;
	ifs.close();
}
```

































































---

